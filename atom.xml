<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cornelius&#39;s Notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunnyWu1104.github.io/"/>
  <updated>2018-06-28T11:20:23.000Z</updated>
  <id>https://sunnyWu1104.github.io/</id>
  
  <author>
    <name>Cornelius</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Docker安装】Linux内核版本影响Docker启动</title>
    <link href="https://sunnyWu1104.github.io/2018/06/28/docker-version-install/"/>
    <id>https://sunnyWu1104.github.io/2018/06/28/docker-version-install/</id>
    <published>2018-06-28T11:07:55.000Z</published>
    <updated>2018-06-28T11:20:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>今天想玩一个开源的应用，顺便想在一台服务器(Ubuntu16.04)上安装Docker(之前在虚拟机上玩的)，加载开源应用的镜像。但是发现Docker启动报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Job for docker.service failed because the control process exited with error code</span><br></pre></td></tr></table></figure><p>使用systemctl status docker.service 查看具体的错误信息:</p><p><img src="http://p95stksgt.bkt.clouddn.com/docker-error.jpg" alt="error"></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>看了网上很多资料都不行，接着排查是否是系统发型版本不对导致错误。官网上支持的发行版本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Docker CE 支持以下版本的 Ubuntu 操作系统：</span><br><span class="line"></span><br><span class="line">Artful 17.10 (Docker CE 17.11 Edge +)</span><br><span class="line">Xenial 16.04 (LTS)</span><br><span class="line">Trusty 14.04 (LTS)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Docker CE 支持以下版本的 Debian 操作系统：</span><br><span class="line"></span><br><span class="line">Buster 10 (Docker CE 17.11 Edge +)</span><br><span class="line">Stretch 9</span><br><span class="line">Jessie 8 (LTS)</span><br><span class="line">Wheezy 7.7 (LTS)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。</span><br><span class="line">CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。</span><br></pre></td></tr></table></figure><p>发现发行版本没有问题，但是CentOS强调Linux内核版本，所以去看了服务器上的内核版本，发现服务器上的版本为：2.6+</p><p>虽然官网没有强调ubuntu也有内核版本的影响，但是我想原因就是出在这！不然我之前在虚拟机上也不会安装成功了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之后看服务器，除了发行版本，也要注意内核版本的不同。</p><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>这里有两种解决办法，可以进行参考(没有验证过)：</p><ol><li><a href="https://blog.csdn.net/G_Barble/article/details/78356126" target="_blank" rel="noopener">解决Docker启动服务器链接失败-Job for docker.service failed because the control process exited error code</a></li><li><a href="https://blog.csdn.net/kwame211/article/details/78799173" target="_blank" rel="noopener">docker安装升级linux内核(2.6.32-&gt;3.10.81)，安装成功！</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h2&gt;&lt;p&gt;今天想玩一个开源的应用，顺便想在一台服务器(Ubuntu16.04)上安装Docker(之前在虚拟机上玩的)，加载开源应用的镜像。但
      
    
    </summary>
    
      <category term="Docker" scheme="https://sunnyWu1104.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://sunnyWu1104.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【github】为了让自己变得更绿</title>
    <link href="https://sunnyWu1104.github.io/2018/06/28/github-green-command/"/>
    <id>https://sunnyWu1104.github.io/2018/06/28/github-green-command/</id>
    <published>2018-06-28T09:20:35.000Z</published>
    <updated>2018-06-28T09:36:10.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="http://p95stksgt.bkt.clouddn.com/github-yu.jpeg" alt="github-yu"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>作为一个程序员，看着自己”绿油油”的github提交记录，一定是一件令人高兴的事。</p><p>然而，用了这么久的github，我今天才注意到，我之前的所有commit都没有被”绿”，只有一些创建项目时的记录，这让我很奇怪。不过github用户记录一定是与邮箱相绑定的。</p><p>于是，我查看了一下commit的详细记录:</p><p><img src="http://p95stksgt.bkt.clouddn.com/github.jpg" alt="github"></p><p>好吧，原来是我在公司的电脑上使用的gitconfig绑定的是公司邮箱，然而github上是自己的谷歌邮箱。</p><p>so，let’s fix this problem！</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><ol><li>全局修改</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.gitconfig 修改配置</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">git config --global user.email you@example.com</span><br></pre></td></tr></table></figure><ol start="2"><li>局部修改</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.email you@example.com</span><br></pre></td></tr></table></figure><ol start="3"><li>也可以修改提交的用户名和Email</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --email=&apos;you@example.com&apos;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>git config是用于进行一些配置设置，有三种不同的方式来指定这些配置适用的范围：</p><ul><li>git config 针对一个git仓库</li><li>git config –global 针对一个用户</li><li>sudo git config –system 针对一个系统，因为是针对整个系统的，所以必须使用sudo</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;http://p95stksgt.bkt.clouddn.com/github-yu.jpeg&quot; alt=&quot;github-yu&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="git-command" scheme="https://sunnyWu1104.github.io/categories/git-command/"/>
    
    
      <category term="github" scheme="https://sunnyWu1104.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Docker三剑客之Swarm项目</title>
    <link href="https://sunnyWu1104.github.io/2018/06/28/docker-swarm/"/>
    <id>https://sunnyWu1104.github.io/2018/06/28/docker-swarm/</id>
    <published>2018-06-28T09:02:52.000Z</published>
    <updated>2018-06-28T09:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Docker Machine让我们更便捷的添加处理主机，Docker Swarm让我们更加方便的管理主机</p></blockquote><h2 id="为什么存在Swarm项目"><a href="#为什么存在Swarm项目" class="headerlink" title="为什么存在Swarm项目"></a>为什么存在Swarm项目</h2><p>Docker Swarm 是 Docker 官方三剑客项目之一，提供 Docker 容器集群服务，是 Docker 官方对容器云生态进行支持的核心方案。</p><p>使用它，用户可以将多个 Docker 主机封装为单个大型的虚拟 Docker 主机，快速打造一套容器云平台。</p><blockquote><p>注意：Docker 1.12 Swarm mode 已经内嵌入 Docker 引擎，成为了 docker 子命令 docker swarm。请注意与旧的 Docker Swarm 区分开来。</p></blockquote><p>Swarm mode 内置 kv 存储功能，提供了众多的新特性，比如：具有容错能力的去中心化设计、内置服务发现、负载均衡、路由网格、动态伸缩、滚动更新、安全传输等。使得 Docker 原生的 Swarm 集群具备与 Mesos、Kubernetes 竞争的实力。</p><h2 id="Docker-Swarm的基本概念"><a href="#Docker-Swarm的基本概念" class="headerlink" title="Docker Swarm的基本概念"></a>Docker Swarm的基本概念</h2><p>Swarm 是使用 SwarmKit 构建的 Docker 引擎内置（原生）的集群管理和编排工具。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>运行 Docker 的主机可以主动初始化一个 Swarm 集群或者加入一个已存在的 Swarm 集群，这样这个运行 Docker 的主机就成为一个 Swarm 集群的节点 (node) 。</p><p><strong>节点分为管理 (manager) 节点和工作 (worker) 节点。</strong></p><p>管理节点用于 Swarm 集群的管理，docker swarm 命令基本只能在管理节点执行（节点退出集群命令 docker swarm leave 可以在工作节点执行）。一个 Swarm 集群可以有多个管理节点，但只有一个管理节点可以成为 leader，leader 通过 raft 协议实现。</p><p>工作节点是任务执行节点，管理节点将服务 (service) 下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点。</p><p><img src="http://p95stksgt.bkt.clouddn.com/docker-swarm01.jpg" alt="docker-swarm01"></p><h3 id="服务和任务"><a href="#服务和任务" class="headerlink" title="服务和任务"></a>服务和任务</h3><p>任务 （Task）是 Swarm 中的最小的调度单位，目前来说就是一个单一的容器。</p><p>服务 （Services） 是指一组任务的集合，服务定义了任务的属性。</p><p>服务有两种模式：</p><ul><li><p>replicated services 按照一定规则在各个工作节点上运行指定个数的任务。</p></li><li><p>global services 每个工作节点上运行一个任务</p></li></ul><p>两种模式通过 docker service create 的 –mode 参数指定。</p><p><img src="http://p95stksgt.bkt.clouddn.com/docker-swarm02.jpg" alt="docker-swarm02"></p><h2 id="创建Swarm集群"><a href="#创建Swarm集群" class="headerlink" title="创建Swarm集群"></a>创建Swarm集群</h2><h3 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h3><h4 id="使用-virtualbox-创建管理节点"><a href="#使用-virtualbox-创建管理节点" class="headerlink" title="使用 virtualbox 创建管理节点"></a>使用 virtualbox 创建管理节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox manager1</span><br><span class="line">#进入管理节点</span><br><span class="line">docker-machine ssh manager1</span><br></pre></td></tr></table></figure><blockquote><p>执行 sudo -i 可以进入Root 权限</p></blockquote><p>使用 docker swarm init 在 manager1 初始化一个 Swarm 集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker@manager1:~$ docker swarm init --advertise-addr 192.168.99.100</span><br></pre></td></tr></table></figure><p>如果你的 Docker 主机有多个网卡，拥有多个 IP，必须使用 –advertise-addr 指定 IP。 执行 docker swarm init 命令的节点自动成为管理节点。</p><p>命令 docker info 可以查看 swarm 集群状态:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Containers: 0</span><br><span class="line">Running: 0</span><br><span class="line">Paused: 0</span><br><span class="line">Stopped: 0</span><br><span class="line">  ...snip...</span><br><span class="line">Swarm: active</span><br><span class="line">  NodeID: dxn1zf6l61qsb1josjja83ngz</span><br><span class="line">  Is Manager: true</span><br><span class="line">  Managers: 1</span><br><span class="line">  Nodes: 1</span><br><span class="line">  ...snip...</span><br></pre></td></tr></table></figure><p>命令 docker node ls 可以查看集群节点信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker@manager1:~$ docker node ls</span><br></pre></td></tr></table></figure><p>退出manager1虚拟主机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker@manager1:~$ exit</span><br></pre></td></tr></table></figure><h4 id="增加工作节点"><a href="#增加工作节点" class="headerlink" title="增加工作节点"></a>增加工作节点</h4><p>上一步初始化了一个 Swarm 集群，拥有了一个管理节点，在 Docker Machine 一节中我们了解到 Docker Machine 可以在数秒内创建一个虚拟的 Docker 主机，下面我们使用它来创建两个 Docker 主机，并加入到集群中。</p><ul><li>创建虚拟主机 worker1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create -d virtualbox worker1</span><br></pre></td></tr></table></figure><ul><li>进入虚拟主机 worker1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh worker1</span><br></pre></td></tr></table></figure><ul><li>加入 swarm 集群</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker@worker1:~$ docker swarm join \</span><br><span class="line">    --token SWMTKN-1-47z6jld2o465z30dl7pie2kqe4oyug4fxdtbgkfjqgybsy4esl-8r55lxhxs7ozfil45gedd5b8a \</span><br><span class="line">    192.168.99.100:2377</span><br></pre></td></tr></table></figure><ul><li>退出虚拟主机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker@worker1:~$ exit</span><br></pre></td></tr></table></figure><ul><li>创建虚拟主机 worker2 步骤同上1～4</li></ul><p>两个工作节点添加完成。</p><h4 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h4><p>进入管理节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh manager1</span><br></pre></td></tr></table></figure><p>宿主机子上查看虚拟主机:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ls</span><br></pre></td></tr></table></figure><p>在主节点上面执行 docker node ls 查询集群主机信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node ls</span><br></pre></td></tr></table></figure><p>到此集群便创建成功了！</p><h2 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h2><p>使用 docker service 命令来管理 Swarm 集群中的服务，该命令只能在管理节点运行。</p><h3 id="新建服务"><a href="#新建服务" class="headerlink" title="新建服务"></a>新建服务</h3><p>进入集群管理节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh manager1</span><br></pre></td></tr></table></figure><p>使用 docker 中国镜像:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search alpine</span><br><span class="line">docker pull registry.docker-cn.com/library/alpine</span><br></pre></td></tr></table></figure><p>在上一节创建的 Swarm 集群中运行一个名为 helloworld 服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker service create --replicas 1 --name helloworld alpine ping baidu.com</span><br><span class="line"></span><br><span class="line">rwpw7eij4v6h6716jvqvpxbyv</span><br><span class="line">overall progress: 1 out of 1 tasks</span><br><span class="line">1/1: running   [==================================================&gt;]</span><br><span class="line">verify: Service converged</span><br></pre></td></tr></table></figure><p>命令解释：</p><ul><li>docker service create 命令创建一个服务</li><li>–name 服务名称命名为 helloworld</li><li>–replicas 设置启动的示例数</li><li>alpine 指的是使用的镜像名称，ping ityouknow.com指的是容器运行的bash</li></ul><p>使用命令 docker service ps rwpw7eij4v6h6716jvqvpxbyv 可以查看服务进展</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service ps rwpw7eij4v6h6716jvqvpxbyv</span><br><span class="line"></span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">rgroe3s9qa53        helloworld.1        alpine:latest       worker1            Running             Running about a minute ago</span><br></pre></td></tr></table></figure><p>使用 docker service ls 来查看当前 Swarm 集群运行的服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE               PORTS</span><br><span class="line">yzfmyggfky8c        helloworld          replicated          0/1                 alpine:latest</span><br></pre></td></tr></table></figure><h3 id="监控集群状态"><a href="#监控集群状态" class="headerlink" title="监控集群状态"></a>监控集群状态</h3><p>登录管理节点 manager1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh manager1</span><br></pre></td></tr></table></figure><p>运行 docker service inspect –pretty <service-id> 查询服务概要状态，以 helloworld 服务为例：</service-id></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">运行 docker service inspect helloworld 查询服务详细信息</span><br><span class="line">docker service inspect --pretty helloworld</span><br><span class="line"></span><br><span class="line">ID:             rwpw7eij4v6h6716jvqvpxbyv</span><br><span class="line">Name:           helloworld</span><br><span class="line">Service Mode:   Replicated</span><br><span class="line"> Replicas:      1</span><br><span class="line">Placement:</span><br><span class="line">UpdateConfig:</span><br><span class="line"> Parallelism:   1</span><br><span class="line"> On failure:    pause</span><br><span class="line"> Monitoring Period: 5s</span><br><span class="line"> Max failure ratio: 0</span><br><span class="line"> ...</span><br><span class="line"> Rollback order:    stop-first</span><br><span class="line">ContainerSpec:</span><br><span class="line"> Image:         alpine:latest@sha256:7b848083f93822dd21b0a2f14a110bd99f6efb4b838d499df6d04a49d0debf8b</span><br><span class="line"> Args:          ping ityouknow.com</span><br><span class="line">Resources:</span><br><span class="line">Endpoint Mode:  vip</span><br></pre></td></tr></table></figure><p>运行docker service ps <service-id>  查看那个节点正在运行服务:</service-id></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service ps helloworld</span><br><span class="line"></span><br><span class="line">NAME                                    IMAGE   NODE     DESIRED STATE  LAST STATE</span><br><span class="line">helloworld.1.8p1vev3fq5zm0mi8g0as41w35  alpine  worker1  Running        Running 3 minutes</span><br></pre></td></tr></table></figure><p>在工作节点查看任务的执行情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh  worker1</span><br></pre></td></tr></table></figure><p>在节点执行docker ps 查看容器的运行状态:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS               NAMES</span><br><span class="line">96bf5b1d8010        alpine:latest       &quot;ping ityouknow.com&quot;   4 minutes ago       Up 4 minutes</span><br></pre></td></tr></table></figure><p>在 Swarm 集群中成功的运行了一个 helloworld 服务，根据命令可以看出在 worker1 节点上运行。</p><h2 id="弹性伸缩实验"><a href="#弹性伸缩实验" class="headerlink" title="弹性伸缩实验"></a>弹性伸缩实验</h2><p>可以使用 docker service scale 对一个服务运行的容器数量进行伸缩。</p><ul><li>当业务处于高峰期时，我们需要扩展服务运行的容器数量:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service scale nginx=5</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line"></span><br><span class="line">docker service update --replicas 5 helloworld</span><br></pre></td></tr></table></figure><ul><li>当业务平稳时，我们需要减少服务运行的容器数量:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service scale nginx=2</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line"></span><br><span class="line">docker service update --replicas 2 helloworld</span><br></pre></td></tr></table></figure><ul><li>删除集群服务:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service rm helloworld</span><br></pre></td></tr></table></figure><ul><li>调整集群大小:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 创建虚拟主机 worker3</span><br><span class="line"> docker-machine create -d virtualbox worker3</span><br><span class="line"></span><br><span class="line">2. 进入虚拟主机 worker3</span><br><span class="line"> docker-machine ssh worker3</span><br><span class="line"></span><br><span class="line">3. 加入swarm 集群</span><br><span class="line"> docker swarm join \</span><br><span class="line">    --token SWMTKN-1-47z6jld2o465z30dl7pie2kqe4oyug4fxdtbgkfjqgybsy4esl-8r55lxhxs7ozfil45gedd5b8a \</span><br><span class="line">    192.168.99.100:2377</span><br></pre></td></tr></table></figure><p>这时进入manager主机查看node，看出集群节点多了 worker3。</p><ul><li>退出 Swarm 集群:</li></ul><p>进入对应的work主机后，执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm leave</span><br></pre></td></tr></table></figure><ul><li>重新搭建命令</li></ul><p>使用 VirtualBox 做测试的时候，如果想重复实验可以将实验节点删掉再重来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//停止虚拟机</span><br><span class="line">docker-machine stop [arg...]  //一个或多个虚拟机名称</span><br><span class="line"></span><br><span class="line">docker-machine stop   manager1 worker1 worker2</span><br><span class="line"></span><br><span class="line">//移除虚拟机</span><br><span class="line">docker-machine rm [OPTIONS] [arg...]</span><br><span class="line"></span><br><span class="line">docker-machine rm manager1 worker1 worker2</span><br></pre></td></tr></table></figure><p>停止、删除虚拟主机后，再重新创建即可。</p><h2 id="在-Swarm-集群中使用-compose-文件"><a href="#在-Swarm-集群中使用-compose-文件" class="headerlink" title="在 Swarm 集群中使用 compose 文件"></a>在 Swarm 集群中使用 compose 文件</h2><p>之前使用 docker-compose.yml 来一次配置、启动多个容器，在 Swarm 集群中也可以使用 compose 文件 （docker-compose.yml） 来配置、启动多个服务。</p><p>以在 Swarm 集群中部署 WordPress 为例进行说明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  wordpress:</span><br><span class="line">    image: wordpress</span><br><span class="line">    ports:</span><br><span class="line">      - 80:80</span><br><span class="line">    networks:</span><br><span class="line">      - overlay</span><br><span class="line">    environment:</span><br><span class="line">      WORDPRESS_DB_HOST: db:3306</span><br><span class="line">      WORDPRESS_DB_USER: wordpress</span><br><span class="line">      WORDPRESS_DB_PASSWORD: wordpress</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 3</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: mysql</span><br><span class="line">    networks:</span><br><span class="line">       - overlay</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/mysql</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: somewordpress</span><br><span class="line">      MYSQL_DATABASE: wordpress</span><br><span class="line">      MYSQL_USER: wordpress</span><br><span class="line">      MYSQL_PASSWORD: wordpress</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    stop_grace_period: 1m30s</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br><span class="line">networks:</span><br><span class="line">  overlay:</span><br></pre></td></tr></table></figure><h3 id="部署compose"><a href="#部署compose" class="headerlink" title="部署compose"></a>部署compose</h3><p>部署服务使用 docker stack deploy，其中 -c 参数指定 compose 文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml wordpress</span><br></pre></td></tr></table></figure><p>打开浏览器输入 任一节点IP:8080 即可看到各节点运行状态。如下图所示：</p><p><img src="http://p95stksgt.bkt.clouddn.com/docker-swarm03.png" alt="docker-swarm03"></p><h3 id="查看服务"><a href="#查看服务" class="headerlink" title="查看服务"></a>查看服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker stack ls</span><br><span class="line"></span><br><span class="line">NAME                SERVICES</span><br><span class="line">wordpress           3</span><br></pre></td></tr></table></figure><h3 id="移除服务"><a href="#移除服务" class="headerlink" title="移除服务"></a>移除服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack down wordpress</span><br></pre></td></tr></table></figure><p>在 Swarm 集群管理节点新建该文件，其中的 visualizer 服务提供一个可视化页面，我们可以从浏览器中很直观的查看集群中各个服务的运行节点。</p><p>在 Swarm 集群中使用 docker-compose.yml 我们用 docker stack 命令，下面我们对该命令进行详细讲解。</p><h2 id="在-Swarm-集群中管理敏感数据"><a href="#在-Swarm-集群中管理敏感数据" class="headerlink" title="在 Swarm 集群中管理敏感数据"></a>在 Swarm 集群中管理敏感数据</h2><p>在动态的、大规模的分布式集群上，管理和分发 密码、证书 等敏感信息是极其重要的工作。传统的密钥分发方式（如密钥放入镜像中，设置环境变量，volume 动态挂载等）都存在着潜在的巨大的安全风险。</p><p>Docker 目前已经提供了 secrets 管理功能，用户可以在 Swarm 集群中安全地管理密码、密钥证书等敏感数据，并允许在多个 Docker 容器实例之间共享访问指定的敏感数据。</p><blockquote><p><strong>注意： secret 也可以在 Docker Compose 中使用。</strong></p></blockquote><h3 id="创建-secret"><a href="#创建-secret" class="headerlink" title="创建 secret"></a>创建 secret</h3><ul><li>创建文件 password.txt，里面存入 Mysql 的 root 密码</li><li>创建文件 wordpress.yml，用于启动 mysql 和 wordpress 服务，内容：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;3.3&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">   db:</span><br><span class="line">     image: mysql:latest</span><br><span class="line">     environment:</span><br><span class="line">       MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_password</span><br><span class="line">       MYSQL_DATABASE: wordpress</span><br><span class="line">     secrets:</span><br><span class="line">       - db_password</span><br><span class="line"></span><br><span class="line">   wordpress:</span><br><span class="line">     depends_on:</span><br><span class="line">       - db</span><br><span class="line">     image: wordpress:latest</span><br><span class="line">     ports:</span><br><span class="line">       - &quot;8000:80&quot;</span><br><span class="line">     environment:</span><br><span class="line">       WORDPRESS_DB_HOST: db:3306</span><br><span class="line">       WORDPRESS_DB_USER: root</span><br><span class="line">       WORDPRESS_DB_PASSWORD_FILE: /run/secrets/db_password</span><br><span class="line">     secrets:</span><br><span class="line">       - db_password</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">   db_password:</span><br><span class="line">     file: password.txt</span><br></pre></td></tr></table></figure><p>启动 wordpress 服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c wordpress.yml wordpress</span><br></pre></td></tr></table></figure><p>除了在Docker Componse里使用，也可以使用 docker secret create 命令以管道符的形式创建 secret</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ openssl rand -base64 20 | docker secret create mysql_password -</span><br><span class="line"></span><br><span class="line">$ openssl rand -base64 20 | docker secret create mysql_root_password -</span><br></pre></td></tr></table></figure><p>创建 MySQL 服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d overlay mysql_private</span><br><span class="line"></span><br><span class="line">$ docker service create \</span><br><span class="line">     --name mysql \</span><br><span class="line">     --replicas 1 \</span><br><span class="line">     --network mysql_private \</span><br><span class="line">     --mount type=volume,source=mydata,destination=/var/lib/mysql \</span><br><span class="line">     --secret source=mysql_root_password,target=mysql_root_password \</span><br><span class="line">     --secret source=mysql_password,target=mysql_password \</span><br><span class="line">     -e MYSQL_ROOT_PASSWORD_FILE=&quot;/run/secrets/mysql_root_password&quot; \</span><br><span class="line">     -e MYSQL_PASSWORD_FILE=&quot;/run/secrets/mysql_password&quot; \</span><br><span class="line">     -e MYSQL_USER=&quot;wordpress&quot; \</span><br><span class="line">     -e MYSQL_DATABASE=&quot;wordpress&quot; \</span><br><span class="line">     mysql:latest</span><br></pre></td></tr></table></figure><p>如果没有在 target 中显式的指定路径时，secret 默认通过 tmpfs 文件系统挂载到容器的 /run/secrets 目录中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">     --name wordpress \</span><br><span class="line">     --replicas 1 \</span><br><span class="line">     --network mysql_private \</span><br><span class="line">     --publish target=30000,port=80 \</span><br><span class="line">     --mount type=volume,source=wpdata,destination=/var/www/html \</span><br><span class="line">     --secret source=mysql_password,target=wp_db_password,mode=0400 \</span><br><span class="line">     -e WORDPRESS_DB_USER=&quot;wordpress&quot; \</span><br><span class="line">     -e WORDPRESS_DB_PASSWORD_FILE=&quot;/run/secrets/wp_db_password&quot; \</span><br><span class="line">     -e WORDPRESS_DB_HOST=&quot;mysql:3306&quot; \</span><br><span class="line">     -e WORDPRESS_DB_NAME=&quot;wordpress&quot; \</span><br><span class="line">     wordpress:latest</span><br></pre></td></tr></table></figure><p>通过以上方法，没有像以前通过设置环境变量来设置 MySQL 密码， 而是采用 docker secret 来设置密码，防范了密码泄露的风险。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在公司流量爆发的时候，只需要执行一个命令就可以完成实例上线。如果再根据公司的业务流量做自动化控制，那就真正实现了完全自动的动态伸缩。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Docker Machine让我们更便捷的添加处理主机，Docker Swarm让我们更加方便的管理主机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么存在Swarm项目&quot;&gt;&lt;a href=&quot;#为什么存在Swarm项目&quot; class=&quot;
      
    
    </summary>
    
      <category term="Docker" scheme="https://sunnyWu1104.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://sunnyWu1104.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>项目平滑部署</title>
    <link href="https://sunnyWu1104.github.io/2018/06/28/deploy-strategy/"/>
    <id>https://sunnyWu1104.github.io/2018/06/28/deploy-strategy/</id>
    <published>2018-06-28T08:58:28.000Z</published>
    <updated>2018-06-28T14:07:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这周需要出一个技术方案，有关于项目部署时尽可能地平滑处理。由此做一下小记，下一篇会对6中部署策略做解释</p></blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>单机服务器我们会面临很多生产上的问题：</p><ol><li><p>怕服务器压力过大，任务处理缓慢</p></li><li><p>内存不足，服务挂了</p></li><li><p>项目发布导致服务停机</p></li></ol><p>…</p><p>考虑到负载均衡，一般的项目都会使用2台以上的服务器。这次我们主要分享项目发布部署的问题。</p><h2 id="单机发布"><a href="#单机发布" class="headerlink" title="单机发布"></a>单机发布</h2><p>在单机情况下，基本上也不需要考虑太多了。。直接kill后，重启容器进行部署。这也是部署策略中的重建策略。这个方式意味着服务的宕机时间依赖于应用下线和启动耗时。</p><h2 id="多机灰度发布"><a href="#多机灰度发布" class="headerlink" title="多机灰度发布"></a>多机灰度发布</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>最容易理解的方式，我们可以通过Nginx做负载均衡，达到较为”平滑”的发布。这种方式优点就是操作比较简单，缺点是影响用户操作。如果某个用户的操作刚好落在正在发布重启的 tomcat 节点上，必然会受到影响，虽然是短暂的。而在其他 tomcat 继续发布的时候，又会扩大这种影响。<br>其实整个过程就是部署策略中的—蓝绿部署。</p><p>一般我们生产环境下，会有两组 tomcat ， 一组用于线上服务（线上组），一组作为备份（备份组）。我们可以先将备份组所有 tomcat 节点部署好，然后修改 nginx 配置文件，切换到备份组，然后操作 nginx 平滑 reload 配置文件。最后再将 线上组 所有 tomcat 节点部署好。 此时 备份组转为线上组，而线上组转为备份组。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>通过Nginx反向代理，达到测试人员使用线上环境针对新的应用进行测试，然而正常用户还是使用原来的应用。整个过程有点像A/B部署策略</p><p>可以根据公网ip进行反向代理，本部门的公网ip是固定的，那么当客户访问的时候，如果是本部门的公网ip的话，nginx进行方向代理到新代码tomcat上，如果非本部门的公网ip，那么代理到原有tomcat上。</p><p>!(nginx)[<a href="http://p95stksgt.bkt.clouddn.com/deploy-nginx.png]" target="_blank" rel="noopener">http://p95stksgt.bkt.clouddn.com/deploy-nginx.png]</a></p><p>参考Nginx代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">upstream jljerp &#123;</span><br><span class="line">           server 192.168.1.190:8001  weight=20 max_fails=2 fail_timeout=30s;</span><br><span class="line">           ip_hash;</span><br><span class="line">                &#125;</span><br><span class="line">upstream jljerp_rc &#123;</span><br><span class="line">           server 192.168.1.190:8004  weight=20 max_fails=2 fail_timeout=30s;</span><br><span class="line">           ip_hash;</span><br><span class="line">                &#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  jljerp.jinlejia.com;</span><br><span class="line">        root   /var/www/index;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">location / &#123;</span><br><span class="line">          proxy_set_header HOST   $host;</span><br><span class="line">          proxy_set_header X-Real-IP      $remote_addr;</span><br><span class="line">          proxy_set_header X-Forwarded-FOR $proxy_add_x_forwarded_for;</span><br><span class="line">          proxy_connect_timeout 600;</span><br><span class="line">          proxy_read_timeout 600;</span><br><span class="line">          proxy_send_timeout 600;</span><br><span class="line">        #  预发布规则，这个地址是部门内部公网地址，当这个地址过来的请求转发到新tomcat上</span><br><span class="line">        if ($remote_addr  ~* &quot;202.106.0.20&quot;) &#123;</span><br><span class="line">          proxy_pass      http://jljerp_rc;</span><br><span class="line">        &#125;</span><br><span class="line">        # 如果不是本部门ip请求，按照原有规则进行原有生产环境进行转发</span><br><span class="line">          proxy_pass      http://jljerp;</span><br><span class="line">              &#125;</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name  www.a.com;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        root   /var/www/a;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        #  预发布规则,如果是本部门的公网的ip，访问这个目录下的地址</span><br><span class="line">         if ($remote_addr  ~* &quot;202.106.0.20&quot;)&#123;</span><br><span class="line">               root    /var/www/b;</span><br><span class="line">               &#125;</span><br><span class="line">    &#125;</span><br><span class="line"># 由于字体使用跨域的方式进行的调用，默认浏览器拒绝访问，加上这个location就可以在其他域名下访问这个域名的字体了</span><br><span class="line">    location ~* \.(eot|ttf|woff|svg|otf|woff2)$ &#123;</span><br><span class="line">             add_header Access-Control-Allow-Origin *;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page  404 500 502 503 504  /404.html;</span><br><span class="line">    location = /404.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这周需要出一个技术方案，有关于项目部署时尽可能地平滑处理。由此做一下小记，下一篇会对6中部署策略做解释&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言
      
    
    </summary>
    
      <category term="deploy" scheme="https://sunnyWu1104.github.io/categories/deploy/"/>
    
    
      <category term="deploy" scheme="https://sunnyWu1104.github.io/tags/deploy/"/>
    
  </entry>
  
  <entry>
    <title>【SS/SSR】GFW与SS/SSR</title>
    <link href="https://sunnyWu1104.github.io/2018/06/28/GFW-SS&amp;SSR/"/>
    <id>https://sunnyWu1104.github.io/2018/06/28/GFW-SS&amp;SSR/</id>
    <published>2018-06-28T08:39:42.000Z</published>
    <updated>2018-06-28T08:39:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1:"></a>Phase 1:</h3><p>起初,我们对网络的访问时非常直接的,我们(客户端)向对方(服务端)发出请求,对方回应请求.</p><p><img src="http://p95stksgt.bkt.clouddn.com/ss1.jpg" alt="ss1"></p><h3 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2:"></a>Phase 2:</h3><p>后来,建立了GFW(Great FireWall),也就是伟大的中国国家防火墙.</p><p><img src="http://p95stksgt.bkt.clouddn.com/ss2.jpg" alt="ss2"></p><p>下面花一点篇幅说几个GFW的封锁原理.</p><h4 id="1-域名解析服务缓存污染"><a href="#1-域名解析服务缓存污染" class="headerlink" title="1.域名解析服务缓存污染"></a>1.域名解析服务缓存污染</h4><p>首先,GFW使用了返回错误的DNS查询结果的方式,比如,当长城监听它骨干出口上某端口的DNS查询(当然这是UDP),接着对其进行入侵检测,一旦发现了和黑名单上关键词相匹配的域名查询请求,就会马上开始当演员,返回一个虚假的结果,这样,我们就会遭遇连接重置，无法获得目标网站的IP地址。</p><h4 id="2-针对境外的IP地址封锁"><a href="#2-针对境外的IP地址封锁" class="headerlink" title="2.针对境外的IP地址封锁"></a>2.针对境外的IP地址封锁</h4><p>防火长城的路由扩散技术中使用的静态路由其实是一条错误的路由，而且是有意配置错误的，其目的就是为了把本来是发往某个IP地址的数据包统统引导到一个“黑洞服务器”上，这个黑洞服务器上可以什么也不做，这样数据包就被无声无息地丢掉了,当然也可以进行一个虚假的回复.接着通过路由重分发,整个网络被打通,大家就都知道这样的IP要发向这么一个黑洞了,效率也得到了提升(封IP封的越来越开心了呢)</p><h4 id="3-IP地址特定端口封锁"><a href="#3-IP地址特定端口封锁" class="headerlink" title="3.IP地址特定端口封锁"></a>3.IP地址特定端口封锁</h4><p>结合2,为了达到更精确的封锁,长城会对特定端口上的数据包进行全部丢弃,以达到更彻底的封锁.</p><p>常常封锁的端口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SSH           TCP      22</span><br><span class="line">HTTP                   80</span><br><span class="line">(PPTP)VPN     TCP      1723</span><br><span class="line">(L2TP)VPN     UDP      1701</span><br><span class="line">IPSec/L2TP    UDP      500&amp;4500</span><br><span class="line">OpenVPN       TCP/UDP  1194</span><br><span class="line">TLS/SSL/HTTPS TCP      443</span><br></pre></td></tr></table></figure><p>另外,中国X动,中国X通等ISP的手机IP端,所有的PPTP都被封锁.</p><h4 id="4-对加密连接的干扰"><a href="#4-对加密连接的干扰" class="headerlink" title="4.对加密连接的干扰"></a>4.对加密连接的干扰</h4><p>(不太了解加密握手可以看看隔壁的TLS/SSL)<br>在连接握手时，因为服务器的公钥是明文传输的，长城会阻断特定证书的加密连接，方法和无状态TCP连接重置一样，都是先发现匹配的黑名单证书，之后通过伪装成对方向连接两端的计算机发送RST干扰两者间正常的TCP连接，进而打断与特定IP地址之间的TLS加密连接握手，或者干脆直接将握手的数据包丢弃导致握手失败，从而导致TLS连接失败.</p><h4 id="5-深度包检测"><a href="#5-深度包检测" class="headerlink" title="5.深度包检测"></a>5.深度包检测</h4><p>深度数据包检测(Deep Package Inspection)是一种于应用层对网络上传递的数据进行侦测与处理的技术，DPI可对报文内容和协议特征进行检测。(似乎这个就是所谓的流量审查)</p><p>在中国大陆，DPI一度被ISP用于追踪用户行为以改善其广告推送业务的精准性，长城赖以检测关键词及嗅探加密流量的重要技术之一.基于必要的硬件设施、适宜的检测模型及相应的模式匹配算法，长城能够精确且快速地从实时网络环境中判别出有悖于预期标准的可疑流量，并对此及时作出相应地应对措施.</p><h3 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase 3:"></a>Phase 3:</h3><p><img src="http://p95stksgt.bkt.clouddn.com/ss3.jpg" alt="ss3"></p><p>针对一些封锁技术,勤劳智慧而又充满勇气的天朝人民,使用了境外HTTP服务器代理,SOCKS服务,VPN 等等各种方式来 Break the GFW.</p><p>然而,尽管SSH是安全的,长城并不能知道里面发生了什么样的数据交换,它却依旧能在建立隧道时,分析连接特征从而进行干扰或是重定向连接.</p><p>其他的几种方式,也都差不多.</p><h3 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase 4:"></a>Phase 4:</h3><p><img src="http://p95stksgt.bkt.clouddn.com/ss4.png" alt="ss4"></p><p>于是,出现了cloudwindy同学…带来的SS,没错,他被警察请去喝茶了.</p><p>延续Phase3,ShadowSocks实际上是将 SSH 创建的<br>SOCKS5协议 拆成两个部分,server 端和 client 端</p><p>不同的地方在于,客户端发出的请求基于 Socks5 协议跟 ss-local 端进行通讯，由于这个 ss-local 一般是本机或路由器或局域网的其他机器，不经过 GFW，所以解决了上面被 GFW 通过特征分析进行干扰的问题.<br>那么,就总体来说一下SS的运作流程:</p><p>首先,在服务器上配置好了 SS 服务器后,用户按照指定的密码、加密方式和端口使用 SS 客户端与其连接。在成功连接到服务器后，客户端会在用户的电脑上构建一个本地<br>Socks5 代理。浏览网络时，网络流量会被分到本地<br>socks5 代理，客户端将其加密之后发送到服务器，服务器以同样的加密方式将流量回传给客户端，以此实现代理上网。</p><h3 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase 5:"></a>Phase 5:</h3><p>后来,似乎GFW对SS的流量有了某种辨识能力,于是,Github上一位叫BreakWa11的作者修改了原SS的代码,增加了混淆以及其他的一些功能(这里面有场不小的风波,从中可以学到一些开源协议的知识…感兴趣的去搜搜看),名为SSR.</p><p>其中使用的混淆机制有:</p><ul><li>http_simple</li><li>tls_simple</li><li>random_head</li><li>tls1.0_session_auth</li></ul><p>说说这其中比较好理解的</p><p>tls1.0_session_auth:模拟TLS1.0在客户端有session ID的情况下的握手连接。因为有session ID所以没有发送证书等复杂步骤，因而防火墙无法根据证书做判断(之前说过),同时自带一定的抗重放攻击的能力。</p><p>由于防火墙对TLS比较无能为力，抗封锁能力较强</p><p>random_head：开始通讯前发送一个几乎为随机的数据包,之后为原协议流。目标是让首个数据包根本不存在任何有效信息,使得GFW的统计学习机制失效.</p><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门:"></a>传送门:</h2><p>转自<a href="https://justin13wyx.me/2017/04/13/SS-SSR/" target="_blank" rel="noopener">【传送门】</a></p><p>Post author: Justin13<br>Post link: <a href="https://justin13wyx.me/2017/04/13/SS-SSR/" target="_blank" rel="noopener">https://justin13wyx.me/2017/04/13/SS-SSR/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Phase-1&quot;&gt;&lt;a href=&quot;#Phase-1&quot; class=&quot;headerlink&quot; title=&quot;Phase 1:&quot;&gt;&lt;/a&gt;Phase 1:&lt;/h3&gt;&lt;p&gt;起初,我们对网络的访问时非常直接的,我们(客户端)向对方(服务端)发出请求,对方回应请求.&lt;/p
      
    
    </summary>
    
      <category term="兴趣" scheme="https://sunnyWu1104.github.io/categories/%E5%85%B4%E8%B6%A3/"/>
    
    
      <category term="SS/SSR" scheme="https://sunnyWu1104.github.io/tags/SS-SSR/"/>
    
  </entry>
  
  <entry>
    <title>Docker三剑客之Machine项目</title>
    <link href="https://sunnyWu1104.github.io/2018/06/28/docker-machine/"/>
    <id>https://sunnyWu1104.github.io/2018/06/28/docker-machine/</id>
    <published>2018-06-28T08:39:42.000Z</published>
    <updated>2018-06-28T08:39:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p95stksgt.bkt.clouddn.com/docker02.png" alt="Docker"></p><hr><blockquote><p>Docker Componse吸引我学习Docker，Machine令我爱上Docker，一定不要错过这两个伟大的项目。严肃脸:)</p></blockquote><h2 id="Docker-Machine-介绍"><a href="#Docker-Machine-介绍" class="headerlink" title="Docker Machine 介绍"></a>Docker Machine 介绍</h2><p>Docker Machine 是 Docker 官方编排（Orchestration）项目之一，负责在多种平台上快速安装 Docker 环境。</p><p>Docker Machine 是一个工具，它允许你在虚拟宿主机上安装 Docker Engine ，并使用 docker-machine 命令管理这些宿主机。你可以使用 Machine 在你本地的 Mac 或 Windows box、公司网络、数据中心、或像 AWS 或 Digital Ocean 这样的云提供商上创建 Docker 宿主机。（跨平台，跨环境）</p><p>使用 docker-machine 命令，你可以启动、审查、停止和重新启动托管的宿主机、升级 Docker 客户端和守护程序、并配置 Docker 客户端与你的宿主机通信。（集中管理）</p><blockquote><p>Docker Machine 项目基于 Go 语言实现（习惯面向对象的同学，学习go的基础语法，不超过一周），目前在 <a href="https://github.com/docker/machine" target="_blank" rel="noopener">Github</a> 上进行维护。</p></blockquote><h3 id="为什么要使用它？"><a href="#为什么要使用它？" class="headerlink" title="为什么要使用它？"></a>为什么要使用它？</h3><ol><li>跨平台跨环境运行Docker</li></ol><p>Machine 允许你在较早的 Mac 或 Windows 系统上运行 Docker</p><p><img src="http://p95stksgt.bkt.clouddn.com/docker-machine01.jpg" alt="docker-machine01"></p><p>如果你主要在不符合新的 Docker for Mac 和 Docker for Windows 应用程序的旧 Mac 或 Windows 笔记本电脑或台式机上工作，则需要 Docker Machine 来在本地“运行Docker”（即Docker Engine）。在 Mac 或 Windows box 中使用 Docker Toolbox 安装程序安装 Docker Machine 将为 Docker Engine 配置一个本地的虚拟机，使你能够连接它、并运行 docker 命令。</p><ol start="2"><li>远程系统集中配置Docker宿主机</li></ol><p><img src="http://p95stksgt.bkt.clouddn.com/docker-machine02.jpg" alt="docker-machine02"></p><p>Docker Engine Linux 系统上原生地运行。如果你有一个 Linux 作为你的主系统，并且想要运行 docker 命令，所有你需要做的就是下载并安装 Docker Engine 。然而，如果你想要在网络上、云中甚至本地配置多个 Docker 宿主机有一个有效的方式，你需要 Docker Machine。</p><p>无论你的主系统是 Mac、Windows 还是 Linux，你都可以在其上安装 Docker Machine，并使用 docker-machine 命令来配置和管理大量的 Docker 宿主机。它会自动创建宿主机、在其上安装 Docker Engine 、然后配置 docker 客户端。每个被管理的宿主机（“machine”）是 Docker 宿主机和配置好的客户端的结合。</p><h3 id="Docker-Engine-和-Docker-Machine-有什么区别？"><a href="#Docker-Engine-和-Docker-Machine-有什么区别？" class="headerlink" title="Docker Engine 和 Docker Machine 有什么区别？"></a>Docker Engine 和 Docker Machine 有什么区别？</h3><p>首先，Docker Engine与Docker Machine都有自己的命令行客户端。但是Docker Machine 是一个用于配置和管理你的宿主机（上面具有 Docker Engine 的主机）的工具，可以使用Docker Machine在一个或多个虚拟系统上安装Docker Engine。</p><p>这些虚拟系统可以是本地的（就像你在 Mac 或 Windows 上使用 Machine 在 VirtualBox 中安装和运行 Docker Engine 一样）或远程的（就像你使用 Machine 在云提供商上 provision Dockerized 宿主机一样）。Dockerized 宿主机本身可以认为是，且有时就称为，被管理的“machines”。</p><p>eg:</p><ul><li>本地系统安装Docker Machine</li><li>利用Docker Machine创建虚拟机</li><li>在虚拟机上就可以玩耍运行 Docker Engine</li></ul><h2 id="安装Docker-Machine"><a href="#安装Docker-Machine" class="headerlink" title="安装Docker Machine"></a>安装Docker Machine</h2><p><a href="https://github.com/docker/machine/releases" target="_blank" rel="noopener">docker-machine-release</a></p><p>On Linux:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://github.com/docker/machine/releases/download/v0.14.0/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machine &amp;&amp;</span><br><span class="line">    chmod +x /tmp/docker-machine &amp;&amp;</span><br><span class="line">    sudo cp /tmp/docker-machine /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure></p><p>On OS X:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://github.com/docker/machine/releases/download/v0.14.0/docker-machine-`uname -s`-`uname -m` &gt;/usr/local/bin/docker-machine &amp;&amp; \</span><br><span class="line">  chmod +x /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure></p><p>On Windows with git bash:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ if [[ ! -d &quot;$HOME/bin&quot; ]]; then mkdir -p &quot;$HOME/bin&quot;; fi &amp;&amp; \</span><br><span class="line">curl -L https://github.com/docker/machine/releases/download/v0.14.0/docker-machine-Windows-x86_64.exe &gt; &quot;$HOME/bin/docker-machine.exe&quot; &amp;&amp; \</span><br><span class="line">chmod +x &quot;$HOME/bin/docker-machine.exe&quot;</span><br></pre></td></tr></table></figure></p><h2 id="使用Docker-Machine"><a href="#使用Docker-Machine" class="headerlink" title="使用Docker Machine"></a>使用Docker Machine</h2><p>Docker Machine 支持多种后端驱动，包括虚拟机、本地主机和云平台等。</p><h3 id="创建本地主机实例-Virtualbox-驱动"><a href="#创建本地主机实例-Virtualbox-驱动" class="headerlink" title="创建本地主机实例:Virtualbox 驱动"></a>创建本地主机实例:Virtualbox 驱动</h3><h4 id="Linux-17-10安装VirtualBox"><a href="#Linux-17-10安装VirtualBox" class="headerlink" title="Linux 17.10安装VirtualBox"></a>Linux 17.10安装VirtualBox</h4><p>这里演示的是一个通过Docker Machine创建一个VirtualBox，但是想要创建VirtualBox，首先需要当前主机已经安装了virtualbox才可以继续。</p><p>如果你使用Mac OS/Windows，那么很幸运，你只需要去VirtualBox的官网下载对应的包即可。如果使用的是Linux操作系统，那么会很麻烦。我这边展示一下使用Linux如果安装VirtualBox（毕竟，方便的事做了也没意思:)）</p><p>我的操作系统版本：Linux 17.10</p><ol><li>Setup Apt Repository</li></ol><p>打开/etc/apt/source.list文件，添加以下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">For Ubuntu 17.10 (&quot;artful&quot;)</span><br><span class="line">deb http://download.virtualbox.org/virtualbox/debian artful contrib</span><br><span class="line"></span><br><span class="line">For Ubuntu 17.04 (&quot;Zesty&quot;)</span><br><span class="line">deb http://download.virtualbox.org/virtualbox/debian zesty contrib</span><br><span class="line"></span><br><span class="line">For Ubuntu 16.04 (&quot;Xenial&quot;)</span><br><span class="line">deb http://download.virtualbox.org/virtualbox/debian xenial contrib</span><br><span class="line"></span><br><span class="line">For Ubuntu 14.04 (&quot;Trusty&quot;)</span><br><span class="line">deb http://download.virtualbox.org/virtualbox/debian trusty contrib</span><br><span class="line"></span><br><span class="line">For Ubuntu 12.04 LTS (&quot;Precise Pangolin&quot;)</span><br><span class="line">deb http://download.virtualbox.org/virtualbox/debian precise contrib</span><br><span class="line"></span><br><span class="line">For Debian 8 (&quot;Jessie&quot;)</span><br><span class="line">deb http://download.virtualbox.org/virtualbox/debian jessie contrib</span><br><span class="line"></span><br><span class="line">For Debian 7 (&quot;Wheezy&quot;)</span><br><span class="line">deb http://download.virtualbox.org/virtualbox/debian wheezy contrib</span><br></pre></td></tr></table></figure><p>不知道名称的，出门左转<a href="http://download.virtualbox.org/virtualbox/debian/dists/" target="_blank" rel="noopener">virtualbox</a></p><ol start="2"><li>Setup Oracle public key</li></ol><p>添加公钥使其信任</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsS https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -</span><br><span class="line">$ curl -fsS https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>这一步和安装Docker时添加官方GPG密钥一致</p><ol start="3"><li>Install Oracle VirtualBox</li></ol><p>愉快的安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install virtualbox-5.1</span><br></pre></td></tr></table></figure><h4 id="创建一个虚拟机"><a href="#创建一个虚拟机" class="headerlink" title="创建一个虚拟机"></a>创建一个虚拟机</h4><p>安装完VirtualBox后，继续创建虚拟主机</p><p>使用 virtualbox 类型的驱动，创建一台 Docker 主机，命名为 default。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox default</span><br></pre></td></tr></table></figure><p>也可以在创建时加上如下参数，来配置主机或者主机上的 Docker:</p><ul><li>–engine-opt dns=114.114.114.114 配置 Docker 的默认 DNS</li><li>–engine-registry-mirror <a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a> 配置 Docker 的仓库镜像</li><li>–virtualbox-memory 2048 配置主机内存</li><li>–virtualbox-cpu-count 2 配置主机 CPU</li></ul><p>ps:</p><p>前一天刚实验完，可以创建在虚拟机内安装并虚拟机，但是今天却再次创建虚拟机的时候就报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This computer doesn&apos;t have VT-X/AMD-v enabled. Enabling it in the BIOS is mandatory</span><br></pre></td></tr></table></figure><p>这表示系统没有开启Intel Virtualization Technology，可是我偏偏该死的用的Virtualbox，这个虚拟机只有EFI(虽然类似bios，但是少了很多选项)并没有bios，试着半天没有办法继续下去。（命令行直接修改没有试过行不行，应该是不行的）</p><p>后来google告诉我虚拟机内是不支持虚拟机的虚拟化。。。要这么说的话，云服务器&amp;云主机&amp;虚拟主机通过虚拟化手段的主机都不能用了。难道我昨天活在梦里了？？？</p><p>这里就不再继续演示virtualbox的驱动了，大家可以找别的玩玩</p><pre><code>•    amazonec2•    azure•    digitalocean•    exoscale•    generic•    google•    hyperv•    none•    openstack•    rackspace•    softlayer•    virtualbox•    vmwarevcloudair•    vmwarefusion•    vmwarevsphere</code></pre><h3 id="创建本地主机实例-macOS-xhyve-驱动"><a href="#创建本地主机实例-macOS-xhyve-驱动" class="headerlink" title="创建本地主机实例:macOS xhyve 驱动"></a>创建本地主机实例:macOS xhyve 驱动</h3><p><a href="https://github.com/zchee/docker-machine-driver-xhyve" target="_blank" rel="noopener">xhyve 驱动</a></p><p>xhyve 是 macOS 上轻量化的虚拟引擎，使用其创建的 Docker Machine 较 VirtualBox 驱动创建的运行效率要高。</p><p>表示没用过，做下记录。有需要的同学可以尝试一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ brew install docker-machine-driver-xhyve</span><br><span class="line"></span><br><span class="line">$ docker-machine create \</span><br><span class="line">      -d xhyve \</span><br><span class="line">      # --xhyve-boot2docker-url ~/.docker/machine/cache/boot2docker.iso \</span><br><span class="line">      --engine-opt dns=114.114.114.114 \</span><br><span class="line">      --engine-registry-mirror https://registry.docker-cn.com \</span><br><span class="line">      --xhyve-memory-size 2048 \</span><br><span class="line">      --xhyve-rawdisk \</span><br><span class="line">      --xhyve-cpu-count 2 \</span><br><span class="line">      xhyve</span><br></pre></td></tr></table></figure><blockquote><p>注意：非首次创建时建议加上 –xhyve-boot2docker-url ~/.docker/machine/cache/boot2docker.iso 参数，避免每次创建时都从 GitHub 下载 ISO 镜像。</p></blockquote><h3 id="创建本地主机实例-Windows-10"><a href="#创建本地主机实例-Windows-10" class="headerlink" title="创建本地主机实例:Windows 10"></a>创建本地主机实例:Windows 10</h3><p>Windows 10 安装 Docker for Windows 之后不能再安装 VirtualBox，也就不能使用 virtualbox 驱动来创建 Docker Machine，我们可以选择使用 hyperv 驱动。</p><blockquote><p>注意，必须事先在 Hyper-V 管理器中新建一个 外部虚拟交换机 执行下面的命令时，使用 –hyperv-virtual-switch=MY_SWITCH 指定虚拟交换机名称</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver hyperv --hyperv-virtual-switch=MY_SWITCH vm</span><br></pre></td></tr></table></figure><h3 id="创建一个主机"><a href="#创建一个主机" class="headerlink" title="创建一个主机"></a>创建一个主机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox default</span><br></pre></td></tr></table></figure><p>这个命令会下载 boot2docker，基于 boot2docker 创建一个虚拟主机。boot2docker 是一个轻量级的 linux 发行版，基于专门为运行 docker 容器而设计的 Tiny Core Linux 系统，完全从 RAM 运行，45Mb左右，启动时间约5s。</p><p>服务列表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ls</span><br></pre></td></tr></table></figure><p>创建主机成功后，可以通过 env 命令来让后续操作对象都是目标主机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine env [主机名]</span><br></pre></td></tr></table></figure><p>可以通过 SSH 登录到主机:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh [主机名]</span><br></pre></td></tr></table></figure><p>连接到主机之后你就可以在其上使用 Docker 了，退出虚拟机使用命令：exit </p><h3 id="在远程主机上安装-Docker"><a href="#在远程主机上安装-Docker" class="headerlink" title="在远程主机上安装 Docker"></a>在远程主机上安装 Docker</h3><p>前提条件：ssh证书登录已打通</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create -d generic \</span><br><span class="line">    --generic-ip-address=xxx.xxx.xxx.xxx \</span><br><span class="line">    --generic-ssh-user=nick \</span><br><span class="line">    --generic-ssh-key ~/.ssh/id_rsa \</span><br><span class="line">    krdevdb</span><br></pre></td></tr></table></figure><h2 id="Docker-Machine-常用命令"><a href="#Docker-Machine-常用命令" class="headerlink" title="Docker Machine 常用命令"></a>Docker Machine 常用命令</h2><p>//创建虚拟机<br>docker-machine create [OPTIONS] [arg…]</p><p>//移除虚拟机<br>docker-machine rm [OPTIONS] [arg…]</p><p>//登录虚拟机<br>docker-machine ssh [arg…]</p><p>//docker客户端配置环境变量<br>docker-machine env [OPTIONS] [arg…]</p><p>//检查机子信息<br>docker-machine inspect</p><p>//查看虚拟机列表<br>docker-machine ls [OPTIONS] [arg…]</p><p>//查看虚拟机状态<br>docker-machine status [arg…]  //一个虚拟机名称</p><p>//启动虚拟机<br>docker-machine start [arg…]  //一个或多个虚拟机名称</p><p>//停止虚拟机<br>docker-machine stop [arg…]  //一个或多个虚拟机名称</p><p>//重启虚拟机<br>docker-machine restart [arg…]  //一个或多个虚拟机名称</p><h2 id="更多命令"><a href="#更多命令" class="headerlink" title="更多命令"></a>更多命令</h2><pre><code>•    active 查看活跃的 Docker 主机•    config 输出连接的配置信息•    create 创建一个 Docker 主机•    env 显示连接到某个主机需要的环境变量•    inspect 输出主机更多信息•    ip 获取主机地址•    kill 停止某个主机•    ls 列出所有管理的主机•    provision 重新设置一个已存在的主机•    regenerate-certs 为某个主机重新生成 TLS 认证信息•    restart 重启主机•    rm 删除某台主机•    ssh SSH 到主机上执行命令•    scp 在主机之间复制文件•    mount 挂载主机目录到本地•    start 启动一个主机•    status 查看主机状态•    stop 停止一个主机•    upgrade 更新主机 Docker 版本为最新•    url 获取主机的 URL•    version 输出 docker-machine 版本信息•    help 输出帮助信息</code></pre><p>每个命令，又带有不同的参数，可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine COMMAND --help</span><br></pre></td></tr></table></figure><p>来查看具体的用法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://p95stksgt.bkt.clouddn.com/docker02.png&quot; alt=&quot;Docker&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;Docker Componse吸引我学习Docker，Machine令我爱上Doc
      
    
    </summary>
    
      <category term="Docker" scheme="https://sunnyWu1104.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://sunnyWu1104.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【Nginx】root和alias指令区别小记</title>
    <link href="https://sunnyWu1104.github.io/2018/06/28/nginx-command/"/>
    <id>https://sunnyWu1104.github.io/2018/06/28/nginx-command/</id>
    <published>2018-06-28T08:39:42.000Z</published>
    <updated>2018-06-28T08:39:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>今天在搭建前端react项目的时候，nginx部署遇到了一个小问题:当前项目下引用的一些静态资源没有加载到，一直报错404，导致样式展示不全。</p><h3 id="排查问题："><a href="#排查问题：" class="headerlink" title="排查问题："></a>排查问题：</h3><ol><li>一直在怀疑是代码中引用的相对路径的问题，修改后问题还是无法修复。</li><li>怀疑nginx容器需要重启，问题还是无法修复。</li><li>排查nginx配置文件信息，发现了一些端倪：</li></ol><h4 id="原配置文件数据"><a href="#原配置文件数据" class="headerlink" title="原配置文件数据:"></a>原配置文件数据:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8800;</span><br><span class="line">        server_name  lcoalhost;</span><br><span class="line">        access_log /data/www/logs/nginx/nginx_access.log  local;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">          root  /data/www/static;</span><br><span class="line">          index index.html;</span><br><span class="line"></span><br><span class="line">#       try_files $uri $uri/index.html;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        error_page  405     =200 $uri;</span><br><span class="line"></span><br><span class="line">         location  /cashwallet &#123;</span><br><span class="line">             alias  /data/www/static;</span><br><span class="line">            index index.html;</span><br><span class="line">            try_files $uri /shaxiaoseng/index.html;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>熟悉nginx的同学，估计在这里一眼就能发现问题了，不过我这边就直接贴出来修改后的配置文件</p><h4 id="修改后的配置文件"><a href="#修改后的配置文件" class="headerlink" title="修改后的配置文件:"></a>修改后的配置文件:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8888;</span><br><span class="line">        server_name  lcoalhost;</span><br><span class="line">        access_log /data/www/logs/nginx/nginx_access.log  local;</span><br><span class="line"></span><br><span class="line">        location /cashwallet &#123;</span><br><span class="line">          root  /data/www/static;</span><br><span class="line">          index index.html;</span><br><span class="line">          try_files $uri /shaxiaoseng/index.html;</span><br><span class="line"></span><br><span class="line">#       try_files $uri $uri/index.html;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        error_page  405     =200 $uri;</span><br></pre></td></tr></table></figure><p><strong> 在这里我们可以发现一些改变：我将location下的alias修改为了root </strong></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因:"></a>原因:</h2><p>alias指令对于root，操作上很简单，只要把root地址替换host后就是文件在硬盘路径（真实地址）。对于alise，它并不是替换匹配后的url地址，而是替换匹配部分的url。alias指令也可以有多个</p><h2 id="eg"><a href="#eg" class="headerlink" title="eg:"></a>eg:</h2><p>使用root指令，查询的资源路径会是: /cashwallet/data/www/static/cashwallet</p><p>使用alias指令，查询的资源路径会是: /data/www/static/cashwallet</p><p>所以会导致查无资源的问题。</p><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门:"></a>传送门:</h2><p>愿意的朋友，可以去<a href="https://www.jianshu.com/p/4be0d5882ec5" target="_blank" rel="noopener">【传送门】</a>看这篇更为详细的介绍对比</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h2&gt;&lt;p&gt;今天在搭建前端react项目的时候，nginx部署遇到了一个小问题:当前项目下引用的一些静态资源没有加载到，一直报错404，导致样式
      
    
    </summary>
    
      <category term="nginx日常小记" scheme="https://sunnyWu1104.github.io/categories/nginx%E6%97%A5%E5%B8%B8%E5%B0%8F%E8%AE%B0/"/>
    
    
      <category term="nginx" scheme="https://sunnyWu1104.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Docker三剑客之Componse项目</title>
    <link href="https://sunnyWu1104.github.io/2018/06/12/docker-componse/"/>
    <id>https://sunnyWu1104.github.io/2018/06/12/docker-componse/</id>
    <published>2018-06-12T03:20:47.000Z</published>
    <updated>2018-06-12T03:45:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p95stksgt.bkt.clouddn.com/docker01.png" alt="Docker"></p><hr><p>Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。<br>本章将介绍 Compose 项目情况以及安装和使用。</p><p>Dockerfile 可以让用户管理一个单独的应用容器；而 Compose 则允许用户在一个模板（YAML 格式）中定义一组相关联的应用容器（被称为一个 project，即项目），例如一个 Web 服务容器再加上后端的数据库服务容器等。</p><p>通过 Docker-Compose 用户可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p><p>Compose 中有两个重要的概念：</p><ul><li>服务 (service) ：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 (project) ：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。<br>一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理，通过子命令对项目中的一组容器进行便捷地生命周期管理。<br>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。</li></ul><blockquote><p>Docker一开始吸引我的点正是：Docker Componse(至少在没看到machine之前我是这么想的=。=、)，我觉得它完美的解决了服务器上一些服务的复杂部署。尤其是mysql、tomcat、nginx等等。Docker Componse就像哆啦A梦的神奇口袋（当然，官方镜像有时候并不能满足我们的需求，那就自己搞呗手动滑稽）</p></blockquote><p>一张图了解一下原理：<br><img src="http://p95stksgt.bkt.clouddn.com/docker-componse01.jpg" width="50%" height="50%"></p><h1 id="Docker-Componse安装"><a href="#Docker-Componse安装" class="headerlink" title="Docker Componse安装"></a>Docker Componse安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">下载</span><br><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.20.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line">安装</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">#安装pip</span><br><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install python-pip</span><br><span class="line">确认版本</span><br><span class="line">pip --version</span><br><span class="line">更新pip</span><br><span class="line">pip install --upgrade pip</span><br><span class="line">安装docker-compose</span><br><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure><h1 id="安装补全工具-可选"><a href="#安装补全工具-可选" class="headerlink" title="安装补全工具(可选)"></a>安装补全工具(可选)</h1><p>为了方便我们输入命令，也可以安装 Docker 的补全提示工具帮忙我们快速输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#安装</span><br><span class="line">yum install bash-completion</span><br><span class="line"></span><br><span class="line">#下载docker-compose脚本</span><br><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/$(docker-compose version --short)/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><h1 id="Docker-Compose-常用命令"><a href="#Docker-Compose-常用命令" class="headerlink" title="Docker Compose 常用命令"></a>Docker Compose 常用命令</h1><p>命令的基本的使用格式是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br><span class="line"></span><br><span class="line">- -f, --file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。</span><br><span class="line">- -p, --project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。</span><br><span class="line">- --x-networking 使用 Docker 的可拔插网络后端特性</span><br><span class="line">- --x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge</span><br><span class="line">- --verbose 输出更多调试信息。</span><br><span class="line">- -v, --version 打印版本并退出。</span><br></pre></td></tr></table></figure><h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p>构建（重新构建）项目中的服务容器</p><p>格式为 docker-compose build [options] [SERVICE…]</p><p>选项包括：</p><pre><code>- --force-rm 删除构建过程中的临时容器。- --no-cache 构建镜像过程中不使用 cache（这将加长构建过程）。- --pull 始终尝试通过 pull 来获取更新版本的镜像。</code></pre><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p><p>格式为 docker-compose config</p><h2 id="down"><a href="#down" class="headerlink" title="down"></a>down</h2><p>此命令将会停止 up 命令所启动的容器，并移除网络</p><p>格式为 docker-compose down</p><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>进入指定的容器。</p><p>格式为 docker-compose exec</p><h2 id="images"><a href="#images" class="headerlink" title="images"></a>images</h2><p>列出 Compose 文件中包含的镜像。</p><p>格式为 docker-compose images</p><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>通过发送 SIGKILL 信号来强制停止服务容器。支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。</p><p>格式为 docker-compose kill [options] [SERVICE…]</p><h2 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h2><p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 –no-color 来关闭颜色。<br>该命令在调试问题的时候十分有用。</p><p>格式为 docker-compose logs [options] [SERVICE…]</p><h2 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h2><p>暂停一个服务容器</p><p>格式为 docker-compose pause</p><h2 id="port"><a href="#port" class="headerlink" title="port"></a>port</h2><p>打印某个容器端口所映射的公共端口</p><p>格式为 docker-compose port [options] SERVICE PRIVATE_PORT</p><p>选项：</p><pre><code>- --protocol=proto 指定端口协议，tcp（默认值）或者 udp。- --index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</code></pre><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>列出项目中目前的所有容器</p><p>格式为 docker-compose ps</p><p>选项：</p><pre><code>- -q 只打印容器的 ID 信息。</code></pre><h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h2><p>拉取服务依赖的镜像</p><p>格式为 docker-compose pull [options] [SERVICE…]</p><p>选项：</p><pre><code>- --ignore-pull-failures 忽略拉取镜像过程中的错误。</code></pre><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>推送服务依赖的镜像到 Docker 镜像仓库</p><p>格式为 docker-compose push</p><h2 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h2><p>重启项目中的服务</p><p>格式为 docker-compose restart [options] [SERVICE…]</p><p>选项：</p><pre><code>- -t, --timeout TIMEOUT 指定重启前停止容器的超时（默认为 10 秒）。</code></pre><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器</p><p>格式为 docker-compose rm [options] [SERVICE…]</p><p>选项：</p><pre><code>- -f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。- -v 删除容器所挂载的数据卷。</code></pre><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>在指定服务上执行一个命令</p><p>格式为 docker-compose run [options] [-p PORT…] [-e KEY=VAL…] SERVICE [COMMAND] [ARGS…]</p><h3 id="eg"><a href="#eg" class="headerlink" title="eg:"></a>eg:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run ubuntu ping docker.com</span><br><span class="line">将会启动一个 ubuntu 服务容器，并执行 ping docker.com 命令</span><br></pre></td></tr></table></figure><p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。<br>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p><p>两个不同点：</p><pre><code>- 给定命令将会覆盖原有的自动运行命令；- 不会自动创建端口，以避免冲突。</code></pre><p>如果不希望自动启动关联的容器，可以使用 –no-deps 选项，将不会启动 web 容器所关联的其它容器。</p><p>选项：</p><pre><code>- -d 后台运行容器。- --name NAME 为容器指定一个名字。- --entrypoint CMD 覆盖默认的容器启动指令。- -e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。- -u, --user=&quot;&quot; 指定运行容器的用户名或者 uid。- --no-deps 不自动启动关联的服务容器。- --rm 运行命令后自动删除容器，d 模式下将忽略。- -p, --publish=[] 映射容器端口到本地主机。- --service-ports 配置服务端口并映射到本地主机。- -T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</code></pre><h2 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h2><p>设置指定服务运行的容器个数，通过 service=num 的参数来设置数量。</p><p>格式为 docker-compose scale [options] [SERVICE=NUM…]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose scale web=3 db=2</span><br><span class="line">将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</span><br><span class="line"></span><br><span class="line">一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</span><br></pre></td></tr></table></figure><p>选项：</p><pre><code>- -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</code></pre><h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>启动已经存在的服务容器</p><p>格式为 docker-compose start [SERVICE…]</p><h2 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h2><p>停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器</p><p>格式为 docker-compose stop [options] [SERVICE…]</p><p>选项：</p><pre><code>- -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</code></pre><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>查看各个服务容器内运行的进程。</p><h2 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a>unpause</h2><p>恢复处于暂停状态中的服务</p><p>格式为 docker-compose unpause [SERVICE…]</p><h2 id="up"><a href="#up" class="headerlink" title="up"></a>up</h2><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p><p>格式为 docker-compose up [options] [SERVICE…]</p><p>默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 docker-compose up –no-recreate。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 docker-compose up –no-deps -d &lt;SERVICE_NAME&gt; 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p><p>选项：</p><pre><code>- -d 在后台运行服务容器。- --no-color 不使用颜色来区分不同的服务的控制台输出。- --no-deps 不启动服务所链接的容器。- --force-recreate 强制重新创建容器，不能与 --no-recreate 同时使用。- --no-recreate 如果容器已经存在了，则不重新创建，不能与 --force-recreate 同时使用。- --no-build 不自动构建缺失的服务镜像。- -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://p95stksgt.bkt.clouddn.com/docker01.png&quot; alt=&quot;Docker&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速的部
      
    
    </summary>
    
      <category term="Docker" scheme="https://sunnyWu1104.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://sunnyWu1104.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile命令详解</title>
    <link href="https://sunnyWu1104.github.io/2018/06/08/dockerfile-command/"/>
    <id>https://sunnyWu1104.github.io/2018/06/08/dockerfile-command/</id>
    <published>2018-06-08T08:10:53.000Z</published>
    <updated>2018-06-08T08:54:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p95stksgt.bkt.clouddn.com/docker01.png" alt="Docker"></p><hr><h2 id="Dockerfile是什么？"><a href="#Dockerfile是什么？" class="headerlink" title="Dockerfile是什么？"></a>Dockerfile是什么？</h2><p>简单说就是：镜像的定制</p><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。<br>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><h2 id="为什么用Dockerfile？"><a href="#为什么用Dockerfile？" class="headerlink" title="为什么用Dockerfile？"></a>为什么用Dockerfile？</h2><p>Dockerfile其实是用于微服务化项目中镜像内容的处理方法。用来定义镜像、依赖镜像来运行容器。<br>使用Dockerfile非常容易的定义镜像内的内容。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了 Dockerfile，当我们需要定制自己额外的需求时，只需在 Dockerfile 上添加或者修改指令，重新生成 image 即可，省去了敲命令的麻烦。</p><p>换言之：我们可以通过一个简单的文件去创建镜像，启动容器等等的一系列脚本的动作。更方便的使我们部署项目</p><h2 id="Dcokerfile文件格式"><a href="#Dcokerfile文件格式" class="headerlink" title="Dcokerfile文件格式"></a>Dcokerfile文件格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">##  Dockerfile文件格式</span><br><span class="line"></span><br><span class="line"># This dockerfile uses the ubuntu image</span><br><span class="line"># VERSION 2 - EDITION 1</span><br><span class="line"># Author: docker_user</span><br><span class="line"># Command format: Instruction [arguments / command] ..</span><br><span class="line"></span><br><span class="line"># 1、第一行必须指定 基础镜像信息</span><br><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line">ps: 除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像</span><br><span class="line">FROM scratch</span><br><span class="line"></span><br><span class="line"># 2、维护者信息</span><br><span class="line">MAINTAINER docker_user docker_user@email.com</span><br><span class="line"></span><br><span class="line"># 3、镜像操作指令</span><br><span class="line">RUN echo &quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class="line">RUN echo &quot;\ndaemon off;&quot; &gt;&gt; /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"># 4、容器启动执行指令</span><br><span class="line">CMD /usr/sbin/nginx</span><br></pre></td></tr></table></figure><h2 id="Dcokerfile指令详解"><a href="#Dcokerfile指令详解" class="headerlink" title="Dcokerfile指令详解"></a>Dcokerfile指令详解</h2><h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM:指定基础镜像"></a>FROM:指定基础镜像</h3><p>FROM 指令用于指定其后构建新镜像所使用的基础镜像。FROM 指令必是 Dockerfile 文件中的首条命令，启动构建流程后，Docker 将会基于该镜像构建新镜像，FROM 后的命令也会基于这个基础镜像。</p><p>FROM语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br><span class="line">或者</span><br><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">或者</span><br><span class="line">FROM &lt;image&gt;:&lt;digest&gt;</span><br></pre></td></tr></table></figure><p>通过 FROM 指定的镜像，可以是任何有效的基础镜像。FROM 有以下限制：</p><ul><li>FROM 必须 是 Dockerfile 中第一条非注释命令</li><li>在一个 Dockerfile 文件中创建多个镜像时，FROM 可以多次出现。只需在每个新命令 FROM 之前，记录提交(run)上次的镜像 ID。</li><li>tag 或 digest 是可选的，如果不使用这两个值时，会使用 latest 版本的基础镜像</li></ul><h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN:执行命令"></a>RUN:执行命令</h3><p>在镜像的构建过程中执行特定的命令，并生成一个中间镜像。格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#shell格式(主要还是用shell方便)</span><br><span class="line">RUN &lt;command&gt;</span><br><span class="line">#exec格式</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br></pre></td></tr></table></figure><ul><li>RUN 命令将在当前 image 中执行任意合法命令并提交执行结果。命令执行提交后，就会自动执行 Dockerfile 中的下一个指令。</li><li>层级 RUN 指令和生成提交是符合 Docker 核心理念的做法。它允许像版本控制那样，在任意一个点，对 image 镜像进行定制化构建。</li><li>RUN 指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定 –no-cache 参数，如：docker build –no-cache。</li></ul><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY:复制文件"></a>COPY:复制文件</h3><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;源路径&gt;... &lt;目标路径&gt;</span><br><span class="line">COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</span><br><span class="line"></span><br><span class="line">使用通配符，其通配符规则要满足 Go 的 filepath.Match 规则</span><br><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">COPY my.cnf /etc/my.cnf</span><br></pre></td></tr></table></figure><h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD:更高级的复制文件"></a>ADD:更高级的复制文件</h3><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。比如&lt;源路径&gt;可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到&lt;目标路径&gt;去。</p><p>在构建镜像时，复制上下文中的文件到镜像内，格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;源路径&gt;... &lt;目标路径&gt;</span><br><span class="line">ADD [&quot;&lt;源路径&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</span><br></pre></td></tr></table></figure><ul><li>如果 docker 发现文件内容被改变，则接下来的指令都不会再使用缓存。关于复制文件时需要处理的/，基本跟正常的 copy 一致</li></ul><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV:设置环境变量"></a>ENV:设置环境变量</h3><p>格式有两种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure></p><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">    NAME=&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure><p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p><h3 id="EXPOSE-设置监听端口"><a href="#EXPOSE-设置监听端口" class="headerlink" title="EXPOSE:设置监听端口"></a>EXPOSE:设置监听端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure><p>EXPOSE 指令并不会让容器监听 host 的端口，如果需要，需要在 docker run 时使用 -p、-P 参数来发布容器端口到 host 的某个端口上。</p><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME:定义匿名卷"></a>VOLUME:定义匿名卷</h3><p>VOLUME用于创建挂载点，即向基于所构建镜像创始的容器添加卷：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br></pre></td></tr></table></figure><p>一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</p><ul><li>卷可以容器间共享和重用</li><li>容器并不一定要和其它容器共享卷</li><li>修改卷后会立即生效</li><li>对卷的修改不会对镜像产生影响</li><li>卷会一直存在，直到没有任何容器在使用它</li></ul><ul><li>VOLUME 让我们可以将源代码、数据或其它内容添加到镜像中，而又不并提交到镜像中，并使我们可以多个容器间共享这些内容。</li></ul><h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR:指定工作目录"></a>WORKDIR:指定工作目录</h3><p>WORKDIR用于在容器内设置一个工作目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure><p>通过WORKDIR设置工作目录后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT、ADD、COPY 等命令都会在该目录下执行。 如，使用WORKDIR设置工作目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure><p>在以上示例中，pwd 最终将会在 /a/b/c 目录中执行。在使用 docker run 运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。</p><h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER:指定当前用户"></a>USER:指定当前用户</h3><p>USER 用于指定运行镜像所使用的用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER daemon</span><br></pre></td></tr></table></figure><p>使用USER指定用户时，可以使用用户名、UID 或 GID，或是两者的组合。以下都是合法的指定试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br></pre></td></tr></table></figure><p>使用USER指定用户后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT 都将使用该用户。镜像构建完成后，通过 docker run 运行容器时，可以通过 -u 参数来覆盖所指定的用户。</p><h3 id="CMD-指定在容器启动时所要执行的命令"><a href="#CMD-指定在容器启动时所要执行的命令" class="headerlink" title="CMD:指定在容器启动时所要执行的命令"></a>CMD:指定在容器启动时所要执行的命令</h3><p>有以下三种格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">CMD command param1 param2(shell)</span><br></pre></td></tr></table></figure><p>省略可执行文件的 exec 格式，这种写法使 CMD 中的参数当做 ENTRYPOINT 的默认参数，此时 ENTRYPOINT 也应该是 exec 格式，具体与 ENTRYPOINT 的组合使用，参考 ENTRYPOINT。</p><ul><li>注意<br>与 RUN 指令的区别：RUN 在构建的时候执行，并生成一个新的镜像，CMD 在容器运行的时候执行，在构建时不进行任何操作。</li></ul><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>ENTRYPOINT 用于给容器配置一个可执行程序。也就是说，每次使用镜像创建容器时，通过 ENTRYPOINT 指定的程序都会被设置为默认程序。ENTRYPOINT 有以下两种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br><span class="line">ENTRYPOINT command param1 param2</span><br></pre></td></tr></table></figure><p>ENTRYPOINT 与 CMD 非常类似，不同的是通过docker run执行的命令不会覆盖 ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给 ENTRYPOINT。Dockerfile 中只允许有一个 ENTRYPOINT 命令，多指定时会覆盖前面的设置，而只执行最后的 ENTRYPOINT 指令。</p><p>docker run运行容器时指定的参数都会被传递给 ENTRYPOINT ，且会覆盖 CMD 命令指定的参数。如，执行docker run <image> -d时，-d 参数将被传递给入口点。</image></p><p>也可以通过docker run –entrypoint重写 ENTRYPOINT 入口点。如：可以像下面这样指定一个容器执行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;/usr/bin/nginx&quot;]</span><br></pre></td></tr></table></figure><p>完整构建代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Version: 0.0.3</span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">MAINTAINER 何民三 &quot;cn.liuht@gmail.com&quot;</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y nginx</span><br><span class="line">RUN echo &apos;Hello World, 我是个容器&apos; \</span><br><span class="line">   &gt; /var/www/html/index.html</span><br><span class="line">ENTRYPOINT [&quot;/usr/sbin/nginx&quot;]</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure><p>使用docker build构建镜像，并将镜像指定为 itbilu/test：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t=&quot;itbilu/test&quot; .  ---后面的路径.别忘了</span><br></pre></td></tr></table></figure><p>构建完成后，使用itbilu/test启动一个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t  itbilu/test -g &quot;daemon off;&quot;</span><br></pre></td></tr></table></figure><p>在运行容器时，我们使用了 -g “daemon off;”，这个参数将会被传递给 ENTRYPOINT，最终在容器中执行的命令为 /usr/sbin/nginx -g “daemon off;”</p><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>LABEL用于为镜像添加元数据，元数以键值对的形式指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure><p>使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。 如，通过LABEL指定一些元数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL version=&quot;1.0&quot; description=&quot;这是一个Web服务器&quot; by=&quot;IT笔录&quot;</span><br></pre></td></tr></table></figure><p>指定后可以通过docker inspect查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker inspect itbilu/test</span><br><span class="line">&quot;Labels&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;这是一个Web服务器&quot;,</span><br><span class="line">    &quot;by&quot;: &quot;IT笔录&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>ARG用于指定传递给构建运行时的变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure><p>如，通过ARG指定两个变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARG site</span><br><span class="line">ARG build_user=IT笔录</span><br></pre></td></tr></table></figure><p>以上我们指定了 site 和 build_user 两个变量，其中 build_user 指定了默认值。在使用 docker build 构建镜像时，可以通过 –build-arg <varname>=<value> 参数来指定或重设置这些变量的值。</value></varname></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --build-arg site=itiblu.com -t itbilu/test .</span><br></pre></td></tr></table></figure><p>这样我们构建了 itbilu/test 镜像，其中site会被设置为 itbilu.com，由于没有指定 build_user，其值将是默认值 IT 笔录。</p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>ONBUILD用于设置镜像触发器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br></pre></td></tr></table></figure><p>当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发。 如，当镜像被使用时，可能需要做一些处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><ul><li>ps:因为在实际项目是依赖镜像的情况还是蛮多的，所以这个也会经常用到</li></ul><h3 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h3><p>STOPSIGNAL用于设置停止容器所要发送的系统调用信号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure><p>所使用的信号必须是内核系统调用表中的合法的值，如：SIGKILL。</p><h3 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h3><p>SHELL用于设置执行命令（shell式）所使用的的默认 shell 类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHELL [&quot;executable&quot;, &quot;parameters&quot;]</span><br></pre></td></tr></table></figure><p>SHELL在Windows环境下比较有用，Windows 下通常会有 cmd 和 powershell 两种 shell，可能还会有 sh。这时就可以通过 SHELL 来指定所使用的 shell 类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM microsoft/windowsservercore</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo default</span><br><span class="line">RUN echo default</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C powershell -command Write-Host default</span><br><span class="line">RUN powershell -command Write-Host default</span><br><span class="line"></span><br><span class="line"># Executed as powershell -command Write-Host hello</span><br><span class="line">SHELL [&quot;powershell&quot;, &quot;-command&quot;]</span><br><span class="line">RUN Write-Host hello</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo hello</span><br><span class="line">SHELL [&quot;cmd&quot;, &quot;/S&quot;&quot;, &quot;/C&quot;]</span><br><span class="line">RUN echo hello</span><br></pre></td></tr></table></figure><h2 id="Dockerfile示例"><a href="#Dockerfile示例" class="headerlink" title="Dockerfile示例"></a>Dockerfile示例</h2><h3 id="构建Nginx运行环境"><a href="#构建Nginx运行环境" class="headerlink" title="构建Nginx运行环境"></a>构建Nginx运行环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 指定基础镜像</span><br><span class="line">FROM sameersbn/ubuntu:14.04.20161014</span><br><span class="line"></span><br><span class="line"># 维护者信息</span><br><span class="line">MAINTAINER sameer@damagehead.com</span><br><span class="line"></span><br><span class="line"># 设置环境</span><br><span class="line">ENV RTMP_VERSION=1.1.10 \</span><br><span class="line">    NPS_VERSION=1.11.33.4 \</span><br><span class="line">    LIBAV_VERSION=11.8 \</span><br><span class="line">    NGINX_VERSION=1.10.1 \</span><br><span class="line">    NGINX_USER=www-data \</span><br><span class="line">    NGINX_SITECONF_DIR=/etc/nginx/sites-enabled \</span><br><span class="line">    NGINX_LOG_DIR=/var/log/nginx \</span><br><span class="line">    NGINX_TEMP_DIR=/var/lib/nginx \</span><br><span class="line">    NGINX_SETUP_DIR=/var/cache/nginx</span><br><span class="line"></span><br><span class="line"># 设置构建时变量，镜像建立完成后就失效</span><br><span class="line">ARG BUILD_LIBAV=false</span><br><span class="line">ARG WITH_DEBUG=false</span><br><span class="line">ARG WITH_PAGESPEED=true</span><br><span class="line">ARG WITH_RTMP=true</span><br><span class="line"></span><br><span class="line"># 复制本地文件到容器目录中</span><br><span class="line">COPY setup/ $&#123;NGINX_SETUP_DIR&#125;/</span><br><span class="line">RUN bash $&#123;NGINX_SETUP_DIR&#125;/install.sh</span><br><span class="line"></span><br><span class="line"># 复制本地配置文件到容器目录中</span><br><span class="line">COPY nginx.conf /etc/nginx/nginx.conf</span><br><span class="line">COPY entrypoint.sh /sbin/entrypoint.sh</span><br><span class="line"></span><br><span class="line"># 运行指令</span><br><span class="line">RUN chmod 755 /sbin/entrypoint.sh</span><br><span class="line"></span><br><span class="line"># 允许指定的端口</span><br><span class="line">EXPOSE 80/tcp 443/tcp 1935/tcp</span><br><span class="line"></span><br><span class="line"># 指定网站目录挂载点</span><br><span class="line">VOLUME [&quot;$&#123;NGINX_SITECONF_DIR&#125;&quot;]</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;/sbin/entrypoint.sh&quot;]</span><br><span class="line">CMD [&quot;/usr/sbin/nginx&quot;]</span><br></pre></td></tr></table></figure><h3 id="构建tomcat-环境"><a href="#构建tomcat-环境" class="headerlink" title="构建tomcat 环境"></a>构建tomcat 环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># 指定基于的基础镜像</span><br><span class="line">FROM ubuntu:13.10</span><br><span class="line"></span><br><span class="line"># 维护者信息</span><br><span class="line">MAINTAINER zhangjiayang &quot;zhangjiayang@sczq.com.cn&quot;</span><br><span class="line"></span><br><span class="line"># 镜像的指令操作</span><br><span class="line"># 获取APT更新的资源列表</span><br><span class="line">RUN echo &quot;deb http://archive.ubuntu.com/ubuntu precise main universe&quot;&gt; /etc/apt/sources.list</span><br><span class="line"># 更新软件</span><br><span class="line">RUN apt-get update</span><br><span class="line"></span><br><span class="line"># Install curl</span><br><span class="line">RUN apt-get -y install curl</span><br><span class="line"></span><br><span class="line"># Install JDK 7</span><br><span class="line">RUN cd /tmp &amp;&amp;  curl -L &apos;http://download.oracle.com/otn-pub/java/jdk/7u65-b17/jdk-7u65-linux-x64.tar.gz&apos; -H &apos;Cookie: oraclelicense=accept-securebackup-cookie; gpw_e24=Dockerfile&apos; | tar -xz</span><br><span class="line">RUN mkdir -p /usr/lib/jvm</span><br><span class="line">RUN mv /tmp/jdk1.7.0_65/ /usr/lib/jvm/java-7-oracle/</span><br><span class="line"></span><br><span class="line"># Set Oracle JDK 7 as default Java</span><br><span class="line">RUN update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-7-oracle/bin/java 300</span><br><span class="line">RUN update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-7-oracle/bin/javac 300</span><br><span class="line"></span><br><span class="line"># 设置系统环境</span><br><span class="line">ENV JAVA_HOME /usr/lib/jvm/java-7-oracle/</span><br><span class="line"></span><br><span class="line"># Install tomcat7</span><br><span class="line">RUN cd /tmp &amp;&amp; curl -L &apos;http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.8/bin/apache-tomcat-7.0.8.tar.gz&apos; | tar -xz</span><br><span class="line">RUN mv /tmp/apache-tomcat-7.0.8/ /opt/tomcat7/</span><br><span class="line"></span><br><span class="line">ENV CATALINA_HOME /opt/tomcat7</span><br><span class="line">ENV PATH $PATH:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line"># 复件tomcat7.sh到容器中的目录</span><br><span class="line">ADD tomcat7.sh /etc/init.d/tomcat7</span><br><span class="line">RUN chmod 755 /etc/init.d/tomcat7</span><br><span class="line"></span><br><span class="line"># Expose ports.  指定暴露的端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line"># Define default command.</span><br><span class="line">ENTRYPOINT service tomcat7 start &amp;&amp; tail -f /opt/tomcat7/logs/catalina.out</span><br></pre></td></tr></table></figure><hr><p>tomcat7.sh命令文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-7-oracle/</span><br><span class="line">export TOMCAT_HOME=/opt/tomcat7</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">start)</span><br><span class="line">  sh $TOMCAT_HOME/bin/startup.sh</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">  sh $TOMCAT_HOME/bin/shutdown.sh</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">  sh $TOMCAT_HOME/bin/shutdown.sh</span><br><span class="line">  sh $TOMCAT_HOME/bin/startup.sh</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h2 id="原则与建议"><a href="#原则与建议" class="headerlink" title="原则与建议"></a>原则与建议</h2><ul><li>容器轻量化。从镜像中产生的容器应该尽量轻量化，能在足够短的时间内停止、销毁、重新生成并替换原来的容器。</li><li>使用 .gitignore。在大部分情况下，Dockerfile 会和构建所需的文件放在同一个目录中，为了提高构建的性能，应该使用 .gitignore 来过滤掉不需要的文件和目录。</li><li>为了减少镜像的大小，减少依赖，仅安装需要的软件包。</li><li>一个容器只做一件事。解耦复杂的应用，分成多个容器，而不是所有东西都放在一个容器内运行。如一个 Python Web 应用，可能需要 Server、DB、Cache、MQ、Log 等几个容器。一个更加极端的说法：One process per container。</li><li>减少镜像的图层。不要多个 Label、ENV 等标签。</li><li>对续行的参数按照字母表排序，特别是使用apt-get install -y安装包的时候。</li><li>使用构建缓存。如果不想使用缓存，可以在构建的时候使用参数–no-cache=true来强制重新生成中间镜像。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://p95stksgt.bkt.clouddn.com/docker01.png&quot; alt=&quot;Docker&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Dockerfile是什么？&quot;&gt;&lt;a href=&quot;#Dockerfile是什么？&quot; class=&quot;
      
    
    </summary>
    
      <category term="Docker" scheme="https://sunnyWu1104.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://sunnyWu1104.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门命令</title>
    <link href="https://sunnyWu1104.github.io/2018/06/07/docker-command/"/>
    <id>https://sunnyWu1104.github.io/2018/06/07/docker-command/</id>
    <published>2018-06-07T11:55:05.000Z</published>
    <updated>2018-06-12T01:58:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Docker是这间博客的第一个系列，有很多内容都引用到了各个大神的内容。我会在这个系列发布的某一个时间点单独发表文章针对各个大神的感谢以及博文出处，在此专题系列的各个文章就不再赘述引用了。希望大神们能够理解。</p></blockquote><p><img src="http://p95stksgt.bkt.clouddn.com/docker01.png" alt="Docker"></p><hr><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><ul><li>用于获取容器/镜像的元数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect</span><br></pre></td></tr></table></figure><ul><li>查看当前系统Docker信息:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><ul><li>查看当前容器使用了多少资源:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats &lt;containerID&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="image"><a href="#image" class="headerlink" title="image"></a>image</h1><ul><li>查找Docker Hub上的nginx镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [image_name]</span><br></pre></td></tr></table></figure><ul><li>拉取docker镜像并启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">- -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</span><br><span class="line">- -d: 后台运行容器，并返回容器 ID；</span><br><span class="line">- -i: 以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">- -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br><span class="line">- --name=&quot;nginx-lb&quot;: 为容器指定一个名称；</span><br><span class="line">- --dns 8.8.8.8: 指定容器使用的 DNS 服务器，默认和宿主一致；</span><br><span class="line">- --dns-search example.com: 指定容器 DNS 搜索域名，默认和宿主一致；</span><br><span class="line">- -h &quot;mars&quot;: 指定容器的 hostname；</span><br><span class="line">- -e username=&quot;ritchie&quot;: 设置环境变量；</span><br><span class="line">- --env-file=[]: 从指定文件读入环境变量；</span><br><span class="line">- --cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定 CPU 运行；</span><br><span class="line">- -m : 设置容器使用内存最大值；</span><br><span class="line">- --net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</span><br><span class="line">- --link=[]: 添加链接到另一个容器；</span><br><span class="line">- --expose=[]: 开放一个端口或一组端口；</span><br></pre></td></tr></table></figure><ul><li>查看宿主机上的镜像，Docker镜像保存在/var/lib/docker目录下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">docker image list</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">docker image ls</span><br></pre></td></tr></table></figure><ul><li>创建镜像文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t [image_name]</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">$ docker image build -t [image_name]:[tag]</span><br></pre></td></tr></table></figure><ul><li>删除镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi  docker.io/tomcat:7.0.77-jre7   或者  docker rmi [image_id]</span><br></pre></td></tr></table></figure><hr><h1 id="container"><a href="#container" class="headerlink" title="container"></a>container</h1><ul><li>生成容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -p [本机端口号]:[容器端口号] -it [image_name] /bin/bash</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">$ docker container run -p 8[本机端口号]:[容器端口号] -it [image_name]:[tag] /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- -p参数：容器的 3000 端口映射到本机的 8000 端口。</span><br><span class="line">- -it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</span><br><span class="line">- /bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</span><br></pre></td></tr></table></figure><ul><li>查看当前有哪些容器正在运行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><ul><li>查看所有容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><ul><li>终止容器运行:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container kill [containerID]</span><br></pre></td></tr></table></figure><ul><li>启动、停止、重启容器命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run  --name [自己定义的容器名称]  -d -p [本机端口号]:[容器端口号] [image_name]:[tag]</span><br><span class="line"></span><br><span class="line">docker start [container_name]/[container_id]</span><br><span class="line">docker stop [container_name]/[container_id]</span><br><span class="line">docker restart [container_name]/[container_id]</span><br></pre></td></tr></table></figure><ul><li>后台启动一个容器后，如果想进入到这个容器，可以使用attach命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker attach [container_name]/[container_id]</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">docker container exec -it [containerID] /bin/bash （进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。）</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">docker exec -it [自己命名的容器名称] bash</span><br></pre></td></tr></table></figure><ul><li>删除容器的命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm [container_name]/[container_id]</span><br><span class="line"></span><br><span class="line">-v : 删除容器的同时，删除数据卷</span><br></pre></td></tr></table></figure><ul><li>删除所有停止的容器：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure><ul><li>在容器终止运行后自动删除容器文件:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --rm -p 8000:3000 -it koa-demo /bin/bash</span><br></pre></td></tr></table></figure><ul><li>从正在运行的 Docker 容器里面，将文件拷贝到本机：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container cp [containID]:[/path/to/file]</span><br></pre></td></tr></table></figure><hr><h1 id="push-image"><a href="#push-image" class="headerlink" title="push image"></a>push image</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、 docker login</span><br><span class="line"></span><br><span class="line">2、docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line">   docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1</span><br><span class="line"></span><br><span class="line">3、 docker image build -t [username]/[repository]:[tag]</span><br><span class="line"></span><br><span class="line">4、docker image push [username]/[repository]:[tag]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Docker是这间博客的第一个系列，有很多内容都引用到了各个大神的内容。我会在这个系列发布的某一个时间点单独发表文章针对各个大神的感谢以及博文出处，在此专题系列的各个文章就不再赘述引用了。希望大神们能够理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="Docker" scheme="https://sunnyWu1104.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://sunnyWu1104.github.io/tags/Docker/"/>
    
  </entry>
  
</feed>
