<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Dockerfile命令详解]]></title>
    <url>%2F2018%2F06%2F08%2Fdockerfile-command%2F</url>
    <content type="text"><![CDATA[Dockerfile是什么？简单说就是：镜像的定制 Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。 为什么用Dockerfile？Dockerfile其实是用于微服务化项目中镜像内容的处理方法。用来定义镜像、依赖镜像来运行容器。使用Dockerfile非常容易的定义镜像内的内容。 Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了 Dockerfile，当我们需要定制自己额外的需求时，只需在 Dockerfile 上添加或者修改指令，重新生成 image 即可，省去了敲命令的麻烦。 换言之：我们可以通过一个简单的文件去创建镜像，启动容器等等的一系列脚本的动作。更方便的使我们部署项目 Dcokerfile文件格式1234567891011121314151617181920212223## Dockerfile文件格式# This dockerfile uses the ubuntu image# VERSION 2 - EDITION 1# Author: docker_user# Command format: Instruction [arguments / command] ..# 1、第一行必须指定 基础镜像信息FROM ubuntups: 除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像FROM scratch# 2、维护者信息MAINTAINER docker_user docker_user@email.com# 3、镜像操作指令RUN echo &quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot; &gt;&gt; /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get install -y nginxRUN echo &quot;\ndaemon off;&quot; &gt;&gt; /etc/nginx/nginx.conf# 4、容器启动执行指令CMD /usr/sbin/nginx Dcokerfile指令详解FROM:指定基础镜像FROM 指令用于指定其后构建新镜像所使用的基础镜像。FROM 指令必是 Dockerfile 文件中的首条命令，启动构建流程后，Docker 将会基于该镜像构建新镜像，FROM 后的命令也会基于这个基础镜像。 FROM语法格式为： 12345FROM &lt;image&gt;或者FROM &lt;image&gt;:&lt;tag&gt;或者FROM &lt;image&gt;:&lt;digest&gt; 通过 FROM 指定的镜像，可以是任何有效的基础镜像。FROM 有以下限制： FROM 必须 是 Dockerfile 中第一条非注释命令 在一个 Dockerfile 文件中创建多个镜像时，FROM 可以多次出现。只需在每个新命令 FROM 之前，记录提交(run)上次的镜像 ID。 tag 或 digest 是可选的，如果不使用这两个值时，会使用 latest 版本的基础镜像 RUN:执行命令在镜像的构建过程中执行特定的命令，并生成一个中间镜像。格式: 1234#shell格式(主要还是用shell方便)RUN &lt;command&gt;#exec格式RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] RUN 命令将在当前 image 中执行任意合法命令并提交执行结果。命令执行提交后，就会自动执行 Dockerfile 中的下一个指令。 层级 RUN 指令和生成提交是符合 Docker 核心理念的做法。它允许像版本控制那样，在任意一个点，对 image 镜像进行定制化构建。 RUN 指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定 –no-cache 参数，如：docker build –no-cache。 COPY:复制文件格式： 123456789COPY &lt;源路径&gt;... &lt;目标路径&gt;COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]使用通配符，其通配符规则要满足 Go 的 filepath.Match 规则COPY hom* /mydir/COPY hom?.txt /mydir/eg:COPY my.cnf /etc/my.cnf ADD:更高级的复制文件ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。比如&lt;源路径&gt;可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到&lt;目标路径&gt;去。 在构建镜像时，复制上下文中的文件到镜像内，格式： 12ADD &lt;源路径&gt;... &lt;目标路径&gt;ADD [&quot;&lt;源路径&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;] 如果 docker 发现文件内容被改变，则接下来的指令都不会再使用缓存。关于复制文件时需要处理的/，基本跟正常的 copy 一致 ENV:设置环境变量格式有两种：12ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;... 这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。 12ENV VERSION=1.0 DEBUG=on \ NAME=&quot;Happy Feet&quot; 这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。 EXPOSE:设置监听端口1EXPOSE &lt;port&gt; [&lt;port&gt;...] EXPOSE 指令并不会让容器监听 host 的端口，如果需要，需要在 docker run 时使用 -p、-P 参数来发布容器端口到 host 的某个端口上。 VOLUME:定义匿名卷VOLUME用于创建挂载点，即向基于所构建镜像创始的容器添加卷： 1VOLUME [&quot;/data&quot;] 一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能： 卷可以容器间共享和重用 容器并不一定要和其它容器共享卷 修改卷后会立即生效 对卷的修改不会对镜像产生影响 卷会一直存在，直到没有任何容器在使用它 VOLUME 让我们可以将源代码、数据或其它内容添加到镜像中，而又不并提交到镜像中，并使我们可以多个容器间共享这些内容。 WORKDIR:指定工作目录WORKDIR用于在容器内设置一个工作目录： 1WORKDIR /path/to/workdir 通过WORKDIR设置工作目录后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT、ADD、COPY 等命令都会在该目录下执行。 如，使用WORKDIR设置工作目录： 1234WORKDIR /aWORKDIR bWORKDIR cRUN pwd 在以上示例中，pwd 最终将会在 /a/b/c 目录中执行。在使用 docker run 运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。 USER:指定当前用户USER 用于指定运行镜像所使用的用户： 1USER daemon 使用USER指定用户时，可以使用用户名、UID 或 GID，或是两者的组合。以下都是合法的指定试： 123456USER userUSER user:groupUSER uidUSER uid:gidUSER user:gidUSER uid:group 使用USER指定用户后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT 都将使用该用户。镜像构建完成后，通过 docker run 运行容器时，可以通过 -u 参数来覆盖所指定的用户。 CMD:指定在容器启动时所要执行的命令有以下三种格式： 123CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]CMD [&quot;param1&quot;,&quot;param2&quot;]CMD command param1 param2(shell) 省略可执行文件的 exec 格式，这种写法使 CMD 中的参数当做 ENTRYPOINT 的默认参数，此时 ENTRYPOINT 也应该是 exec 格式，具体与 ENTRYPOINT 的组合使用，参考 ENTRYPOINT。 注意与 RUN 指令的区别：RUN 在构建的时候执行，并生成一个新的镜像，CMD 在容器运行的时候执行，在构建时不进行任何操作。 ENTRYPOINTENTRYPOINT 用于给容器配置一个可执行程序。也就是说，每次使用镜像创建容器时，通过 ENTRYPOINT 指定的程序都会被设置为默认程序。ENTRYPOINT 有以下两种形式： 12ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]ENTRYPOINT command param1 param2 ENTRYPOINT 与 CMD 非常类似，不同的是通过docker run执行的命令不会覆盖 ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给 ENTRYPOINT。Dockerfile 中只允许有一个 ENTRYPOINT 命令，多指定时会覆盖前面的设置，而只执行最后的 ENTRYPOINT 指令。 docker run运行容器时指定的参数都会被传递给 ENTRYPOINT ，且会覆盖 CMD 命令指定的参数。如，执行docker run -d时，-d 参数将被传递给入口点。 也可以通过docker run –entrypoint重写 ENTRYPOINT 入口点。如：可以像下面这样指定一个容器执行程序： 1ENTRYPOINT [&quot;/usr/bin/nginx&quot;] 完整构建代码： 123456789# Version: 0.0.3FROM ubuntu:16.04MAINTAINER 何民三 &quot;cn.liuht@gmail.com&quot;RUN apt-get updateRUN apt-get install -y nginxRUN echo &apos;Hello World, 我是个容器&apos; \ &gt; /var/www/html/index.htmlENTRYPOINT [&quot;/usr/sbin/nginx&quot;]EXPOSE 80 使用docker build构建镜像，并将镜像指定为 itbilu/test： 1docker build -t=&quot;itbilu/test&quot; . ---后面的路径.别忘了 构建完成后，使用itbilu/test启动一个容器： 1docker run -i -t itbilu/test -g &quot;daemon off;&quot; 在运行容器时，我们使用了 -g “daemon off;”，这个参数将会被传递给 ENTRYPOINT，最终在容器中执行的命令为 /usr/sbin/nginx -g “daemon off;” LABELLABEL用于为镜像添加元数据，元数以键值对的形式指定： 1LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ... 使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。 如，通过LABEL指定一些元数据： 1LABEL version=&quot;1.0&quot; description=&quot;这是一个Web服务器&quot; by=&quot;IT笔录&quot; 指定后可以通过docker inspect查看： 123456docker inspect itbilu/test&quot;Labels&quot;: &#123; &quot;version&quot;: &quot;1.0&quot;, &quot;description&quot;: &quot;这是一个Web服务器&quot;, &quot;by&quot;: &quot;IT笔录&quot;&#125;, ARGARG用于指定传递给构建运行时的变量： 1ARG &lt;name&gt;[=&lt;default value&gt;] 如，通过ARG指定两个变量： 12ARG siteARG build_user=IT笔录 以上我们指定了 site 和 build_user 两个变量，其中 build_user 指定了默认值。在使用 docker build 构建镜像时，可以通过 –build-arg = 参数来指定或重设置这些变量的值。 1docker build --build-arg site=itiblu.com -t itbilu/test . 这样我们构建了 itbilu/test 镜像，其中site会被设置为 itbilu.com，由于没有指定 build_user，其值将是默认值 IT 笔录。 ONBUILDONBUILD用于设置镜像触发器： 1ONBUILD [INSTRUCTION] 当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发。 如，当镜像被使用时，可能需要做一些处理： 1234[...]ONBUILD ADD . /app/srcONBUILD RUN /usr/local/bin/python-build --dir /app/src[...] ps:因为在实际项目是依赖镜像的情况还是蛮多的，所以这个也会经常用到 STOPSIGNALSTOPSIGNAL用于设置停止容器所要发送的系统调用信号： 1STOPSIGNAL signal 所使用的信号必须是内核系统调用表中的合法的值，如：SIGKILL。 SHELLSHELL用于设置执行命令（shell式）所使用的的默认 shell 类型： 1SHELL [&quot;executable&quot;, &quot;parameters&quot;] SHELL在Windows环境下比较有用，Windows 下通常会有 cmd 和 powershell 两种 shell，可能还会有 sh。这时就可以通过 SHELL 来指定所使用的 shell 类型： 123456789101112131415FROM microsoft/windowsservercore# Executed as cmd /S /C echo defaultRUN echo default# Executed as cmd /S /C powershell -command Write-Host defaultRUN powershell -command Write-Host default# Executed as powershell -command Write-Host helloSHELL [&quot;powershell&quot;, &quot;-command&quot;]RUN Write-Host hello# Executed as cmd /S /C echo helloSHELL [&quot;cmd&quot;, &quot;/S&quot;&quot;, &quot;/C&quot;]RUN echo hello Dockerfile示例构建Nginx运行环境123456789101112131415161718192021222324252627282930313233343536373839404142# 指定基础镜像FROM sameersbn/ubuntu:14.04.20161014# 维护者信息MAINTAINER sameer@damagehead.com# 设置环境ENV RTMP_VERSION=1.1.10 \ NPS_VERSION=1.11.33.4 \ LIBAV_VERSION=11.8 \ NGINX_VERSION=1.10.1 \ NGINX_USER=www-data \ NGINX_SITECONF_DIR=/etc/nginx/sites-enabled \ NGINX_LOG_DIR=/var/log/nginx \ NGINX_TEMP_DIR=/var/lib/nginx \ NGINX_SETUP_DIR=/var/cache/nginx# 设置构建时变量，镜像建立完成后就失效ARG BUILD_LIBAV=falseARG WITH_DEBUG=falseARG WITH_PAGESPEED=trueARG WITH_RTMP=true# 复制本地文件到容器目录中COPY setup/ $&#123;NGINX_SETUP_DIR&#125;/RUN bash $&#123;NGINX_SETUP_DIR&#125;/install.sh# 复制本地配置文件到容器目录中COPY nginx.conf /etc/nginx/nginx.confCOPY entrypoint.sh /sbin/entrypoint.sh# 运行指令RUN chmod 755 /sbin/entrypoint.sh# 允许指定的端口EXPOSE 80/tcp 443/tcp 1935/tcp# 指定网站目录挂载点VOLUME [&quot;$&#123;NGINX_SITECONF_DIR&#125;&quot;]ENTRYPOINT [&quot;/sbin/entrypoint.sh&quot;]CMD [&quot;/usr/sbin/nginx&quot;] 构建tomcat 环境12345678910111213141516171819202122232425262728293031323334353637383940414243# 指定基于的基础镜像FROM ubuntu:13.10# 维护者信息MAINTAINER zhangjiayang &quot;zhangjiayang@sczq.com.cn&quot;# 镜像的指令操作# 获取APT更新的资源列表RUN echo &quot;deb http://archive.ubuntu.com/ubuntu precise main universe&quot;&gt; /etc/apt/sources.list# 更新软件RUN apt-get update# Install curlRUN apt-get -y install curl# Install JDK 7RUN cd /tmp &amp;&amp; curl -L &apos;http://download.oracle.com/otn-pub/java/jdk/7u65-b17/jdk-7u65-linux-x64.tar.gz&apos; -H &apos;Cookie: oraclelicense=accept-securebackup-cookie; gpw_e24=Dockerfile&apos; | tar -xzRUN mkdir -p /usr/lib/jvmRUN mv /tmp/jdk1.7.0_65/ /usr/lib/jvm/java-7-oracle/# Set Oracle JDK 7 as default JavaRUN update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-7-oracle/bin/java 300RUN update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-7-oracle/bin/javac 300# 设置系统环境ENV JAVA_HOME /usr/lib/jvm/java-7-oracle/# Install tomcat7RUN cd /tmp &amp;&amp; curl -L &apos;http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.8/bin/apache-tomcat-7.0.8.tar.gz&apos; | tar -xzRUN mv /tmp/apache-tomcat-7.0.8/ /opt/tomcat7/ENV CATALINA_HOME /opt/tomcat7ENV PATH $PATH:$CATALINA_HOME/bin# 复件tomcat7.sh到容器中的目录ADD tomcat7.sh /etc/init.d/tomcat7RUN chmod 755 /etc/init.d/tomcat7# Expose ports. 指定暴露的端口EXPOSE 8080# Define default command.ENTRYPOINT service tomcat7 start &amp;&amp; tail -f /opt/tomcat7/logs/catalina.out tomcat7.sh命令文件 12345678910111213141516export JAVA_HOME=/usr/lib/jvm/java-7-oracle/export TOMCAT_HOME=/opt/tomcat7case $1 instart) sh $TOMCAT_HOME/bin/startup.sh;;stop) sh $TOMCAT_HOME/bin/shutdown.sh;;restart) sh $TOMCAT_HOME/bin/shutdown.sh sh $TOMCAT_HOME/bin/startup.sh;;esacexit 0 原则与建议 容器轻量化。从镜像中产生的容器应该尽量轻量化，能在足够短的时间内停止、销毁、重新生成并替换原来的容器。 使用 .gitignore。在大部分情况下，Dockerfile 会和构建所需的文件放在同一个目录中，为了提高构建的性能，应该使用 .gitignore 来过滤掉不需要的文件和目录。 为了减少镜像的大小，减少依赖，仅安装需要的软件包。 一个容器只做一件事。解耦复杂的应用，分成多个容器，而不是所有东西都放在一个容器内运行。如一个 Python Web 应用，可能需要 Server、DB、Cache、MQ、Log 等几个容器。一个更加极端的说法：One process per container。 减少镜像的图层。不要多个 Label、ENV 等标签。 对续行的参数按照字母表排序，特别是使用apt-get install -y安装包的时候。 使用构建缓存。如果不想使用缓存，可以在构建的时候使用参数–no-cache=true来强制重新生成中间镜像。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门命令]]></title>
    <url>%2F2018%2F06%2F07%2Fdocker-command%2F</url>
    <content type="text"><![CDATA[Docker是这间博客的第一个系列，有很多内容都引用到了各个大神的内容。我会在这个系列发布的某一个时间点单独发表文章针对各个大神的感谢以及博文出处，在此专题系列的各个文章就不再赘述引用了。希望大神们能够理解。 docker 用于获取容器/镜像的元数据 1docker inspect 查看当前系统Docker信息: 1docker info 查看当前容器使用了多少资源: 1docker stats &lt;containerID&gt; image 查找Docker Hub上的nginx镜像 1docker search [image_name] 拉取docker镜像并启动 123456789101112131415161718docker run [OPTIONS] IMAGE [COMMAND] [ARG...]options:- -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；- -d: 后台运行容器，并返回容器 ID；- -i: 以交互模式运行容器，通常与 -t 同时使用；- -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；- --name=&quot;nginx-lb&quot;: 为容器指定一个名称；- --dns 8.8.8.8: 指定容器使用的 DNS 服务器，默认和宿主一致；- --dns-search example.com: 指定容器 DNS 搜索域名，默认和宿主一致；- -h &quot;mars&quot;: 指定容器的 hostname；- -e username=&quot;ritchie&quot;: 设置环境变量；- --env-file=[]: 从指定文件读入环境变量；- --cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定 CPU 运行；- -m : 设置容器使用内存最大值；- --net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；- --link=[]: 添加链接到另一个容器；- --expose=[]: 开放一个端口或一组端口； 查看宿主机上的镜像，Docker镜像保存在/var/lib/docker目录下: 123456789docker images或者docker image list或者docker image ls 创建镜像文件 12345$ docker image build -t [image_name]或者$ docker image build -t [image_name]:[tag] 删除镜像 1docker rmi docker.io/tomcat:7.0.77-jre7 或者 docker rmi [image_id] container 生成容器 12345$ docker container run -p [本机端口号]:[容器端口号] -it [image_name] /bin/bash或者$ docker container run -p 8[本机端口号]:[容器端口号] -it [image_name]:[tag] /bin/bash 123- -p参数：容器的 3000 端口映射到本机的 8000 端口。- -it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。- /bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。 查看当前有哪些容器正在运行 1docker ps 查看所有容器 1docker ps -a 终止容器运行: 1docker container kill [containerID] 启动、停止、重启容器命令： 12345docker run --name [自己定义的容器名称] -d -p [本机端口号]:[容器端口号] [image_name]:[tag]docker start [container_name]/[container_id]docker stop [container_name]/[container_id]docker restart [container_name]/[container_id] 后台启动一个容器后，如果想进入到这个容器，可以使用attach命令： 123456789docker attach [container_name]/[container_id]或者docker container exec -it [containerID] /bin/bash （进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。）或者docker exec -it [自己命名的容器名称] bash 删除容器的命令： 1docker rm [container_name]/[container_id] 删除所有停止的容器： 1docker rm $(docker ps -a -q) 在容器终止运行后自动删除容器文件: 1docker container run --rm -p 8000:3000 -it koa-demo /bin/bash 从正在运行的 Docker 容器里面，将文件拷贝到本机： 1docker container cp [containID]:[/path/to/file] push image123456781、 docker login2、docker image tag [imageName] [username]/[repository]:[tag] docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.13、 docker image build -t [username]/[repository]:[tag]4、docker image push [username]/[repository]:[tag]]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SS/SSR】GFW与SS/SSR]]></title>
    <url>%2F2018%2F06%2F04%2FGFW%E4%B8%8ESS%26SSR%2F</url>
    <content type="text"><![CDATA[Phase 1:起初,我们对网络的访问时非常直接的,我们(客户端)向对方(服务端)发出请求,对方回应请求. Phase 2:后来,建立了GFW(Great FireWall),也就是伟大的中国国家防火墙. 下面花一点篇幅说几个GFW的封锁原理. 1.域名解析服务缓存污染首先,GFW使用了返回错误的DNS查询结果的方式,比如,当长城监听它骨干出口上某端口的DNS查询(当然这是UDP),接着对其进行入侵检测,一旦发现了和黑名单上关键词相匹配的域名查询请求,就会马上开始当演员,返回一个虚假的结果,这样,我们就会遭遇连接重置，无法获得目标网站的IP地址。 2.针对境外的IP地址封锁防火长城的路由扩散技术中使用的静态路由其实是一条错误的路由，而且是有意配置错误的，其目的就是为了把本来是发往某个IP地址的数据包统统引导到一个“黑洞服务器”上，这个黑洞服务器上可以什么也不做，这样数据包就被无声无息地丢掉了,当然也可以进行一个虚假的回复.接着通过路由重分发,整个网络被打通,大家就都知道这样的IP要发向这么一个黑洞了,效率也得到了提升(封IP封的越来越开心了呢) 3.IP地址特定端口封锁结合2,为了达到更精确的封锁,长城会对特定端口上的数据包进行全部丢弃,以达到更彻底的封锁. 常常封锁的端口: 1234567SSH TCP 22HTTP 80(PPTP)VPN TCP 1723(L2TP)VPN UDP 1701IPSec/L2TP UDP 500&amp;4500OpenVPN TCP/UDP 1194TLS/SSL/HTTPS TCP 443 另外,中国X动,中国X通等ISP的手机IP端,所有的PPTP都被封锁. 4.对加密连接的干扰(不太了解加密握手可以看看隔壁的TLS/SSL)在连接握手时，因为服务器的公钥是明文传输的，长城会阻断特定证书的加密连接，方法和无状态TCP连接重置一样，都是先发现匹配的黑名单证书，之后通过伪装成对方向连接两端的计算机发送RST干扰两者间正常的TCP连接，进而打断与特定IP地址之间的TLS加密连接握手，或者干脆直接将握手的数据包丢弃导致握手失败，从而导致TLS连接失败. 5.深度包检测深度数据包检测(Deep Package Inspection)是一种于应用层对网络上传递的数据进行侦测与处理的技术，DPI可对报文内容和协议特征进行检测。(似乎这个就是所谓的流量审查) 在中国大陆，DPI一度被ISP用于追踪用户行为以改善其广告推送业务的精准性，长城赖以检测关键词及嗅探加密流量的重要技术之一.基于必要的硬件设施、适宜的检测模型及相应的模式匹配算法，长城能够精确且快速地从实时网络环境中判别出有悖于预期标准的可疑流量，并对此及时作出相应地应对措施. Phase 3: 针对一些封锁技术,勤劳智慧而又充满勇气的天朝人民,使用了境外HTTP服务器代理,SOCKS服务,VPN 等等各种方式来 Break the GFW. 然而,尽管SSH是安全的,长城并不能知道里面发生了什么样的数据交换,它却依旧能在建立隧道时,分析连接特征从而进行干扰或是重定向连接. 其他的几种方式,也都差不多. Phase 4: 于是,出现了cloudwindy同学…带来的SS,没错,他被警察请去喝茶了. 延续Phase3,ShadowSocks实际上是将 SSH 创建的SOCKS5协议 拆成两个部分,server 端和 client 端 不同的地方在于,客户端发出的请求基于 Socks5 协议跟 ss-local 端进行通讯，由于这个 ss-local 一般是本机或路由器或局域网的其他机器，不经过 GFW，所以解决了上面被 GFW 通过特征分析进行干扰的问题.那么,就总体来说一下SS的运作流程: 首先,在服务器上配置好了 SS 服务器后,用户按照指定的密码、加密方式和端口使用 SS 客户端与其连接。在成功连接到服务器后，客户端会在用户的电脑上构建一个本地Socks5 代理。浏览网络时，网络流量会被分到本地socks5 代理，客户端将其加密之后发送到服务器，服务器以同样的加密方式将流量回传给客户端，以此实现代理上网。 Phase 5:后来,似乎GFW对SS的流量有了某种辨识能力,于是,Github上一位叫BreakWa11的作者修改了原SS的代码,增加了混淆以及其他的一些功能(这里面有场不小的风波,从中可以学到一些开源协议的知识…感兴趣的去搜搜看),名为SSR. 其中使用的混淆机制有: http_simple tls_simple random_head tls1.0_session_auth 说说这其中比较好理解的 tls1.0_session_auth:模拟TLS1.0在客户端有session ID的情况下的握手连接。因为有session ID所以没有发送证书等复杂步骤，因而防火墙无法根据证书做判断(之前说过),同时自带一定的抗重放攻击的能力。 由于防火墙对TLS比较无能为力，抗封锁能力较强 random_head：开始通讯前发送一个几乎为随机的数据包,之后为原协议流。目标是让首个数据包根本不存在任何有效信息,使得GFW的统计学习机制失效. 传送门:转自【传送门】 Post author: Justin13Post link: https://justin13wyx.me/2017/04/13/SS-SSR/]]></content>
      <categories>
        <category>兴趣</category>
      </categories>
      <tags>
        <tag>SS/SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[【Nginx】root和alias指令区别小记]]></title>
    <url>%2F2018%2F06%2F04%2F%E3%80%90Nginx%E3%80%91root%E5%92%8Calias%E6%8C%87%E4%BB%A4%E5%8C%BA%E5%88%AB%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[问题：今天在搭建前端react项目的时候，nginx部署遇到了一个小问题:当前项目下引用的一些静态资源没有加载到，一直报错404，导致样式展示不全。 排查问题： 一直在怀疑是代码中引用的相对路径的问题，修改后问题还是无法修复。 怀疑nginx容器需要重启，问题还是无法修复。 排查nginx配置文件信息，发现了一些端倪： 原配置文件数据:1234567891011121314151617181920server &#123; listen 8800; server_name lcoalhost; access_log /data/www/logs/nginx/nginx_access.log local; location / &#123; root /data/www/static; index index.html;# try_files $uri $uri/index.html; &#125; error_page 405 =200 $uri; location /cashwallet &#123; alias /data/www/static; index index.html; try_files $uri /shaxiaoseng/index.html; &#125; 熟悉nginx的同学，估计在这里一眼就能发现问题了，不过我这边就直接贴出来修改后的配置文件 修改后的配置文件:123456789101112131415server &#123; listen 8888; server_name lcoalhost; access_log /data/www/logs/nginx/nginx_access.log local; location /cashwallet &#123; root /data/www/static; index index.html; try_files $uri /shaxiaoseng/index.html;# try_files $uri $uri/index.html; &#125; error_page 405 =200 $uri; 在这里我们可以发现一些改变：我将location下的alias修改为了root 原因:alias指令对于root，操作上很简单，只要把root地址替换host后就是文件在硬盘路径（真实地址）。对于alise，它并不是替换匹配后的url地址，而是替换匹配部分的url。alias指令也可以有多个 eg:使用root指令，查询的资源路径会是: /cashwallet/data/www/static/cashwallet 使用alias指令，查询的资源路径会是: /data/www/static/cashwallet 所以会导致查无资源的问题。 传送门:愿意的朋友，可以去【传送门】看这篇更为详细的介绍对比]]></content>
      <categories>
        <category>nginx日常小记</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
</search>
